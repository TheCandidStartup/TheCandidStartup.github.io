---
title: Bootstrapping API Extractor
tags: frontend
---

wise words

```
npm install -D @microsoft/api-extractor

added 30 packages, removed 6 packages, and audited 1015 packages in 5s
```

```
% npx api-extractor init

api-extractor 7.47.0  - https://api-extractor.com/

Writing file: /Users/tim/GitHub/infinisheet/api-extractor.json

The recommended location for this file is in the project's "config" subfolder,
or else in the top-level folder with package.json.
```

Config file produced includes full reference documentation for each option as comments. It's huge. Pages and pages of it. It's allow a sea of red squiggly lines in VS Code because JSON files don't support comments. Except you see JSON files with comments all the time. For example, `tsconfig.json`. 

Rabbit hole time. Internally VS Code supports two parsers for JSON. A standard compliant one for the "json" format, and another one for "jsonc" which does support comments. You can setup file associations that map file patterns to the parser to use. By default `tsconfig.json` and `tsconfig.*.json` are mapped to "jsonc". Makes sense. TypeScript is a Microsoft product. Apparently, some third party config file formats also have default rules that map them to "jsonc". However, for some reason "api-extractor.json" gets no special treatment and you have to setup a file association yourself. 

Edited config file to set the mandatory `mainEntryPointFilePath` property to point at the `dist/index.d.ts` file generated by my Rollup build. Disabled API Extractor from trying to generate its own rollup of my rollup.

```
% npx api-extractor run --local --verbose

api-extractor 7.47.0  - https://api-extractor.com/

Using configuration from ./api-extractor.json
Analysis will use the bundled TypeScript version 5.4.2
*** The target project appears to use TypeScript 5.5.2 which is newer than the bundled compiler engine; consider upgrading API Extractor.
Writing: /Users/tim/GitHub/infinisheet/packages/react-virtual-scroll/temp/react-virtual-scroll.api.json
Generating complete API report: /Users/tim/GitHub/infinisheet/packages/react-virtual-scroll/etc/react-virtual-scroll.api.md
Error: Unable to create the API report file. Please make sure the target folder exists:
/Users/tim/GitHub/infinisheet/packages/react-virtual-scroll/etc
Warning: dist/index.d.ts:55:1 - (ae-missing-release-tag) "VirtualInnerProps" is part of the package's API, but it is missing a release tag (@alpha, @beta, @public, or @internal)
Warning: dist/index.d.ts:55:1 - (ae-unresolved-link) The @link reference could not be resolved: The package "@candidstartup/react-virtual-scroll" does not have an export "VirtualInnerComponent"
...
```

* Worrying message about TypeScript versions. I've just installed the latest version of API Extractor. Digging deeper [suggests](https://github.com/microsoft/rushstack/issues/4404) that this is a common state of affairs and generally nothing to worry about. API Extractor only needs uses the TypeScript compiler to read the `*.d.ts` file which is much simpler and less likely to have significant changes from version to version.
* I changed the config so that the API report goes into the project folder rather than `./etc`. 
* That just leaves the long list of errors. Despite being described as warnings, the [documentation](https://api-extractor.com/pages/setup/configure_api_report/) says they result in a nonzero exit code which would cause production builds to fail. You can configure things so that selected warnings go into the API report instead. 
* Looking at the generated `react-virtual-scroll.api.md` there are lots more warnings there. 

```ts
// Warning: (ae-forgotten-export) The symbol "FixedSizeItemOffsetMapping" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useFixedSizeItemOffsetMapping(itemSize: number): FixedSizeItemOffsetMapping;
```

* I had subconsciously been following a policy of explicitly exporting the top level symbols that a user would directly import but not dependent symbols. Up to this point everything has worked. Api Extractor is suggesting that every dependency needs to be explicitly exported. 
* Works for simple cases. IntelliSense help not limited by rules of type system. Compiler can infer types in some cases. You can use value of a property of unexported type. 
* Won't work if user writes code that accesses type explicitly. For example, extending it. Or declaring a variable of that type. 
* Correct thing is to export everything visible.
* Went through and made sure everything referenced by public API is explicitly exported.
* Lots of common stuff in `VirtualBase.ts`. All of it needs exporting apart from one bit of common implementation used by `VirtualList.tsx` and `VirtualGrid.tsx`
* Moved the implementation into `VirtualCommon.ts` so I can safely export `VirtualBase` as a whole
* For now don't want to bother with explicitly adding release tags to everything in the API so have disabled that warning.

```js
  "messages": {
    "extractorMessageReporting": {
      "ae-missing-release-tag": {
        "logLevel": "none"
      }
    }
  }
```

That left me with two remaining errors

```
Warning: dist/index.d.ts:50:5 - (ae-unresolved-link) The @link reference could not be resolved: No member was found with name "maxCssSize"
Warning: dist/index.d.ts:185:5 - (ae-unresolved-link) The @link reference could not be resolved: No member was found with name "data"
```

Both of these are real problems caused by typos in my TSDoc comments. 

* Now fixed all the warnings in console and API report
* Left with one intriguing comment at the bottom of the report: `// (No @packageDocumentation comment for this package)`
* Comment with [this tag](https://api-extractor.com/pages/tsdoc/tag_packagedocumentation/) is used by the API documentation generator to describe the package as a whole.
* Needs to be first comment in `index.d.ts`. Easy, add it at the top of `index.ts`.
* The comment gets copied into `index.d.ts` by the TypeScript compiler. 
* Rollup helpfully removes the comment when generating my rolled up `index.d.ts` because it doesn't apply to anything.
* Tried hack of defining a dummy exported type for comment to apply to. Comment makes it into rolled up file but API Extractor still complains because comment needs to be literally the first thing in the file. 
* Will need to rework my build pipeline so that API Extractor runs on output of tsc before Rollup generates final bundle
* Could use API Extractor to produce bundled `index.d.ts` rather than Rollup dts plugin
* Before doing that, let's look at API Documenter and see if it's worth doing

```
% npm install -D @microsoft/api-documenter

added 4 packages, and audited 1019 packages in 3s
```

* Need to configure API extractor to also output a "docModel" `.api.json` file. By default it gets put into a `temp` subdir.
* API Documenter reads the docModel file and generates Markdown API documentation
* You can then run the Markdown files through whatever publishing pipeline you like. 
  * Upload to a GitHub repo and use the GitHub integrated markdown viewer
  * Upload to GitHub and publish as a static website using GitHub pages
  * Use a custom GitHub actions workflow to generate the Markdown, transform and publish

* By default api-documenter will try to read from an `input` subdir and write to `markdown` output dir. 

```
npx api-documenter markdown -i temp

api-documenter 7.25.4  - https://api-extractor.com/

Reading react-virtual-scroll.api.json

Deleting old output from ./markdown
Writing @candidstartup/react-virtual-scroll package
```

* Now I need to publish the markdown to see if the output is any good. I have a quick and dirty way that I've used before. I copy the markdown into my local repo for this blog and let my local Jekyll publishing environment handle the rest. It didn't come out as I expected.

{% include candid-image.html src="/assets/images/github/api-documenter-candid-github-pages.png" alt="Published docs using Candid Startup theme" %}

* The publishing pipeline is meant to convert relative markdown links like `[ScrollState](./scrollstate.md)` to html, renaming `.md` to `.html` in the process.
* Most of the links are left as markdown. Those that are converted to html still have the `.md` extension and take you to the markdown source. Then there's lots of random garbled markup visible in the output.
* I initially thought the problem must be with my local Jekyll setup. I changed a few likely looking configuration options. Updated to the latest version. Still broken.
* To rule out my local environment I temporarily checked the markdown files in to GitHub.
* They look fine in GitHub's Markdown viewer. Links are converted and functional. No visible garbled markup.

{% include candid-image.html src="/assets/images/github/api-documenter-github-markdown.png" alt="Published docs in GitHub Markdown viewer" %}

* However once published to the blob via GitHub pages I get the same garbled mess that I see locally.
* Next thought was there must be something wrong with my hacked together Candid Startup Jekyll theme.
* I uploaded the markdown again to a separate repo and setup GitHub Pages publishing using the in built defaults

{% include candid-image.html src="/assets/images/github/api-documenter-default-github-pages.png" alt="Published docs using GitHub defaults" %}

* This time the extensions have all been converted from `.md` to `.html`. However, most of the links are left in Markdown format and the garbled markdown is still there. 
* Finally, I started to wonder about the quality of the API Documenter output. The Markdown output includes html tables with markdown content in each cell.

```html
<tbody><tr><td>

[ScrollState](./react-virtual-scroll.scrollstate.md)

</td><td>
```

* Does that really work? No it doesn't. Turns out that this was introduced in API Documenter v7.24 a couple of months ago. Prior to that the output used Markdown tables. This has [broken](https://github.com/microsoft/rushstack/issues/4586) lots of Markdown publishers and the change is likely to be rolled back. 
* I downgraded to v7.23.38 and regenerated the Markdown. As expected all the tables use Markdown syntax throughout.
* Ran through local Jekyll publishing and all the links are converted to html, no garbled markup. Suffixes are still `.md` however.
* Back to checking my Jekyll setup. Facepalm moment. I'd forgotten that I tried using relative links between blog posts when I was setting things up. That doesn't work. I'd left things with relative links disabled.  Relative links is part of the default Github Pages setup. Once I removed the leftovers from my experiments the links worked correctly. 
* Unfortunately, there's still some broken formatting. Comments with multiple paragraphs result in Markdown with explicit html paragraph tags. Put that in a Markdown table and GitHub Pages can't handle it. 

```md
|  [VirtualList](./react-virtual-scroll.virtuallist.md) | <p>Virtual Scrolling List</p><p>Accepts props defined by [VirtualListProps](./react-virtual-scroll.virtuallistprops.md)<!-- -->. Refs are forwarded to [VirtualListProxy](./react-virtual-scroll.virtuallistproxy.md)<!-- -->. You must pass a single instance of [VirtualListItem](./react-virtual-scroll.virtuallistitem.md) as a child.</p> |
```

{% include candid-image.html src="/assets/images/github/api-documenter-para-tags-github-pages.png" alt="Published docs with paragraph tags in GitHub Pages" %}

* At this point I gave up. API extractor does three things. One of them is useful, one doesn't work and one I have another solution for. I'll tidy things up and add the API report to the build process. I think I'll need to look elsewhere for documentation generation. Luckily, there are other options to look at.
* If I'd known in advance I wouldn't have bothered with API Extractor. It's a heavyweight solution for a glorified lint plugin. 
