---
title: Unique Ids
tags: cloud-architecture autodesk
---

They say that there are only [two hard problems](https://martinfowler.com/bliki/TwoHardThings.html) in Computer Science: cache invalidation and naming things. Cache invalidation is far too difficult, so let's have a go at naming things. Specifically, how do you ensure that the name you use to identify some resource is unique?

The first question you should ask yourself is, unique in what context? Am I trying to make sure that both of my pet cats have different names, or that the local veterinary practice can find the correct records when I take one in, or that the RFID chips implanted in most pets have unique numbers?

The wider scoped the context, the more effort it takes. It didn't take our family long to come up with names for the cats, or to ensure that they were different. There was no formal process involved.

Coming up with a scheme for [implantable microchip ids](https://en.wikipedia.org/wiki/Microchip_implant_(animal)) is clearly more complex. Most of the world has settled on chips that use the [ISO 11784 and ISO 11785](https://en.wikipedia.org/wiki/ISO_11784_and_ISO_11785) standards. This specifies a 15 digit id where the first 3 digits identify a country or manufacturer that is responsible for generating the other 12 digits. The US uses the ISO system together with three other proprietary standards. 

Which nicely illustrates the three main characteristics of any system of ids
1. Who decides how the system works? How many parties are involved? What happens if they can't agree?
2. What's the format for the ids? Crucially, how many different possible ids does the system allow?
3. Who generates the ids? How do they ensure that new ids are unique? What happens if you need multiple generators?

## Sequential Id

The simplest form of unique id is sequential, usually in the form of an incrementing integer. A single generator (for example, a relational database) keeps track of the most recent id generated and increments it when the next id is required. The only choice to make is how large the integer should be. In most cases you're choosing between 32 bit and 64 bit. 

In most cases you should go for 64 bit. The number of ids available is effectively unlimited. You could generate a billion ids a second and it would be 500 years before you ran out. 

It can be tempting to use 32 bit ids. Four billion ids seems like it should be enough for most purposes. However, it is surprisingly easy to run out as systems scale up. If the ids are used to name objects that are created and later deleted, you may run out of ids even if the current population of objects is small. Reusing ids adds complexity and opens up the door to all sorts of interesting bugs. For example, the Postgres relational database uses 32 bit ids for transactions which needs [careful management](https://www.postgresql.org/docs/15/routine-vacuuming.html#VACUUM-FOR-MULTIXACT-WRAPAROUND) to avoid problems when the id counter wraps around.

Only use a 32 bit or smaller id when you really can't afford the space of a larger id AND there's a hard limit on the number of active objects AND you have a way of coping when ids wrap around.

## Meaningful Id

## Universal Unique Id (UUID)

## Universal Resource Name (URN)

## Universal Unique Lexicographically Sortable Id (ULID)

* Alternative is ULIDs. 128 bit value like UUID consisting of 48 bit timestamp in milliseconds and 80 bits of randomness. ULIDs generated by different servers in same millisecond are arbitrarily ordered by randomness. ULIDs generated by same client in same millisecond are monotonically ordered by library recognizing this case and returning last ULID+1.
  * If clocks are skewed can get entries inserted earlier in order. Have to do something nasty like waiting for 30 seconds before relying on order.
  * Non-start for me
* More controlled eventually consistent order? Use a singleton Epoch counter. e.g. singleton DynamoDB item with an atomic counter. Streams+Lambda process increments counter on any change, with delay to update once every few milliseconds. Lambda can propagate current Epoch value to other items (e.g. one per shard) to scale read bandwidth if needed. Sort key is current Epoch + large random value. Use with server side conflict resolution. Ignore pending transactions until epoch has moved on. When creating new entry need to check that current entry has same or earlier epoch before attempting to write. ARRGH. Doesn't work. Need absolutely predictable id for next entry to use conditional write to enforce constraint. Have to use transaction with CheckCondition? Doesn't help, need to know that epoch has ended across all shards. 

* https://github.com/ulid/spec
* https://www.microsoft.com/en-us/research/uploads/prod/2020/12/TO-Algs-Bernstein-GoodmanVLDB1980.pdf
* https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c
* https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68
