---
title: Unique Ids
tags: cloud-architecture
---

* Unique in what context?

## Sequential Id

## Universal Unique Id (UUID)

## Universal Unique Lexicographically Sortable Id (ULID)

* Alternative is ULIDs. 128 bit value like UUID consisting of 48 bit timestamp in milliseconds and 80 bits of randomness. ULIDs generated by different servers in same millisecond are arbitrarily ordered by randomness. ULIDs generated by same client in same millisecond are monotonically ordered by library recognizing this case and returning last ULID+1.
  * If clocks are skewed can get entries inserted earlier in order. Have to do something nasty like waiting for 30 seconds before relying on order.
  * Non-start for me
* More controlled eventually consistent order? Use a singleton Epoch counter. e.g. singleton DynamoDB item with an atomic counter. Streams+Lambda process increments counter on any change, with delay to update once every few milliseconds. Lambda can propagate current Epoch value to other items (e.g. one per shard) to scale read bandwidth if needed. Sort key is current Epoch + large random value. Use with server side conflict resolution. Ignore pending transactions until epoch has moved on. When creating new entry need to check that current entry has same or earlier epoch before attempting to write. ARRGH. Doesn't work. Need absolutely predictable id for next entry to use conditional write to enforce constraint. Have to use transaction with CheckCondition? Doesn't help, need to know that epoch has ended across all shards. 

* https://github.com/ulid/spec
* https://www.microsoft.com/en-us/research/uploads/prod/2020/12/TO-Algs-Bernstein-GoodmanVLDB1980.pdf
* https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c
* https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68
