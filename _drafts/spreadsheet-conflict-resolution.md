---
title: Conflict Resolution for an Event Sourced Spreadsheet
tags: spreadsheets
---

## Future Work

### Write Sharding

* Alternative is ULIDs. 128 bit value like UUID consisting of 48 bit timestamp in milliseconds and 80 bits of randomness. ULIDs generated by different servers in same millisecond are arbitrarily ordered by randomness. ULIDs generated by same client in same millisecond are monotonically ordered by library recognizing this case and returning last ULID+1.
  * If clocks are skewed can get entries inserted earlier in order. Have to do something nasty like waiting for 30 seconds before relying on order.
  * Non-start for me
* More controlled eventually consistent order? Use a singleton Epoch counter. e.g. singleton DynamoDB item with an atomic counter. Streams+Lambda process increments counter on any change, with delay to update once every few milliseconds. Lambda can propagate current Epoch value to other items (e.g. one per shard) to scale read bandwidth if needed. Sort key is current Epoch + large random value. Use with server side conflict resolution. Ignore pending transactions until epoch has moved on. When creating new entry need to check that current entry has same or earlier epoch before attempting to write. ARRGH. Doesn't work. Need absolutely predictable id for next entry to use conditional write to enforce constraint. Have to use transaction with CheckCondition? Doesn't help, need to know that epoch has ended across all shards. 
  
### Conflict Resolution

* Simplest approach is last writer wins. Clients submit their changes, source of truth is order changes hit transaction log, client sync most recent changes and fix up their local state if it has diverged
* Strictest approach extends add entry logic back to client. Client syncs to most recent changes, resolving any conflict locally. Submits their changes conditional on no changes to transaction log since their sync. If transaction fails, sync and repeat.
* Server side conflict resolution.
  * Submit changes including entry number (segment num + entry num?) of last change client has seen. Transaction written to log but marked pending. Clients ignore pending changes (or treat them as non-definitive). Snapshot creation can't start until pending transaction resolved. 
  * Server side process works through pending transactions in order. For each, looks at any entries added to the log between the last change the client saw and the submitted transaction and checks for conflicts. 
    * Lots of ways to define conflict - could specify how strict you want to be in transaction. Simplest is to check whether any cell the transaction depends on was modified by earlier change. 
    * Wider scope would check for any cell changing in a row that transaction depends on. 
    * Or could support arbitrary conditions ...
  * Transaction is marked as rejected or accepted. Rejected transactions are ignored by everyone (filter them out when querying)
  * 

## Coming Up

Next time ...

* Import
* Insert Rows
* Insert Columns
* Delete Rows
* Delete Columns
* Set Cell
* Set Cells
* Batch
* Snapshot
* End Segment