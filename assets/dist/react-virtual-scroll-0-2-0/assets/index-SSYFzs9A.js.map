{"version":3,"file":"index-SSYFzs9A.js","sources":["../../../../packages/react-virtual-scroll/src/VirtualBase.ts","../../../../packages/react-virtual-scroll/src/useVirtualScroll.ts","../../../../packages/react-virtual-scroll/src/useEventListener.ts","../../../../packages/react-virtual-scroll/src/useAnimationTimeout.ts","../../../../packages/react-virtual-scroll/src/useIsScrolling.ts","../../../../packages/react-virtual-scroll/src/VirtualGrid.tsx","../../../../packages/react-virtual-scroll/src/VirtualList.tsx","../../../../packages/react-virtual-scroll/src/useFixedSizeItemOffsetMapping.ts","../../../../packages/react-virtual-scroll/src/useVariableSizeItemOffsetMapping.ts"],"sourcesContent":["\nexport interface VirtualBaseItemProps {\n  data: any,\n  isScrolling?: boolean,\n  style: Object,\n};\n\nexport interface VirtualBaseProps {\n  height: number,\n  width: number,\n  itemData?: any,\n  useIsScrolling?: boolean,\n};\n\nexport interface ItemOffsetMapping {\n  itemSize(itemIndex: number): number;\n  itemOffset(itemIndex: number): number;\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number];\n};\n\nexport type ScrollEvent = React.SyntheticEvent<HTMLDivElement>;\n\ntype RangeToRender = [\n  startIndex: number,\n  startOffset: number,\n  sizes: number[]\n];\n\nexport function getRangeToRender(itemCount: number, itemOffsetMapping: ItemOffsetMapping, clientExtent: number, scrollOffset: number): RangeToRender {\n  if (itemCount == 0) {\n    return [0, 0, []];\n  }\n\n  var [itemIndex, startOffset] = itemOffsetMapping.offsetToItem(scrollOffset);\n  itemIndex = Math.max(0, Math.min(itemCount - 1, itemIndex));\n  var endOffset = scrollOffset + clientExtent;\n\n  const overscanBackward = 1;\n  const overscanForward = 1;\n\n  for (let step = 0; step < overscanBackward && itemIndex > 0; step ++) {\n    itemIndex --;\n    startOffset -= itemOffsetMapping.itemSize(itemIndex);\n  }\n\n  const startIndex = itemIndex;\n  var offset = startOffset;\n  const sizes: number[] = [];\n\n  while (offset < endOffset && itemIndex < itemCount) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    offset += size;\n    itemIndex ++;\n  }\n\n  for (let step = 0; step < overscanForward && itemIndex < itemCount; step ++) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    itemIndex ++;\n  }\n\n  return [startIndex, startOffset, sizes];\n}\n","import { useState } from \"react\";\n\nexport type ScrollDirection = \"forward\" | \"backward\";\nexport interface ScrollState { \n  scrollOffset: number, \n  renderOffset: number,\n  page: number, \n  scrollDirection: ScrollDirection, \n};\n\nexport interface VirtualScroll extends ScrollState {\n  renderSize: number;\n\n  // Returns updated scrollOffset. Caller should update scroll bar position if different from value passed in. \n  onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): number;\n\n  // Scroll to offset in logical space returning offset to update scroll bar position to\n  doScrollTo(offset: number, clientExtent: number): number;\n};\n\n// Max size that is safe across all browsers (Firefox is the limiting factor)\n// SlickGrid tries to dynamically determine limit on other browsers (Chrome will do 30M) but\n// I prefer simplicity of same behavior across all browsers.\nconst MAX_SUPPORTED_CSS_SIZE = 6000000;\nconst MIN_NUMBER_PAGES = 100;\n\nexport function useVirtualScroll(totalSize: number): VirtualScroll {\n  let renderSize=0, pageSize=0, numPages=0;\n  if (totalSize < MAX_SUPPORTED_CSS_SIZE) {\n    // No paging needed\n    renderSize = pageSize = totalSize;\n    numPages = 1;\n  } else {\n    // Break into pages\n    renderSize = MAX_SUPPORTED_CSS_SIZE;\n    pageSize = renderSize / MIN_NUMBER_PAGES;\n    numPages = Math.floor(totalSize / pageSize);\n  }\n\n  function pageToRenderOffset(page: number): number {\n    if (page <= 0)\n      return 0;\n\n    if (page >= numPages-1)\n      return totalSize - renderSize;\n\n    return Math.round((page-1) * (totalSize - renderSize) / (numPages - 3));\n  }\n\n  const initValue: ScrollState = { \n    scrollOffset: 0, \n    renderOffset: 0,\n    page: 0,\n    scrollDirection: \"forward\",\n  };\n  const [scrollState, setScrollState] = useState(initValue);\n\n  function onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number) {\n    if (scrollState.scrollOffset == scrollOffset) {\n      // No need to change state if scroll position unchanged\n      return scrollOffset;\n    }\n\n    // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n    let newOffset = Math.max(0, Math.min(scrollOffset, scrollExtent - clientExtent));\n    const newScrollDirection = scrollState.scrollOffset <= newOffset ? 'forward' : 'backward';\n\n    // Switch pages if needed\n    let newPage, newRenderOffset;\n    let retScrollOffset = scrollOffset;\n    const scrollDist = Math.abs(newOffset - scrollState.scrollOffset);\n    if (scrollDist < clientExtent) {\n      // Scrolling part of visible window, don't want to skip items, so can't scale up movement\n      // If we cross page boundary we need to reset scroll bar position back to where it should be at start of page\n      newPage = Math.min(numPages - 1, Math.floor((scrollOffset + scrollState.renderOffset) / pageSize));\n      newRenderOffset = pageToRenderOffset(newPage);\n      if (newPage != scrollState.page) {\n        // Be very intentional about when we ask caller to reset scroll bar\n        // Don't want to trigger event loops\n        newOffset = scrollOffset + scrollState.renderOffset - newRenderOffset;\n        retScrollOffset = newOffset;\n      }\n    } else {\n      // Large scale scrolling, choosing page from a rolodex\n      // First and last page are mapped 1:1 between grid and container\n      if (newOffset < pageSize) {\n        newPage = 0;\n      } else if (newOffset >= renderSize - pageSize) {\n        newPage = numPages - 1;\n      } else {\n        const scaleFactor = (totalSize - pageSize*2) / (renderSize - pageSize*2);\n        newPage = Math.min(numPages - 3, Math.floor((newOffset - pageSize) * scaleFactor / pageSize)) + 1;\n      }\n      newRenderOffset = pageToRenderOffset(newPage);\n    }\n\n    setScrollState({ scrollOffset: newOffset, renderOffset: newRenderOffset, page: newPage, scrollDirection: newScrollDirection });\n    return retScrollOffset;\n  }\n\n  function doScrollTo(offset: number, clientExtent: number) {\n    const safeOffset = Math.min(totalSize - clientExtent, Math.max(offset, 0));\n    const scrollDirection = (scrollState.scrollOffset + scrollState.renderOffset) <= safeOffset ? 'forward' : 'backward';\n    const page = Math.min(numPages - 1, Math.floor(safeOffset / pageSize));\n    const renderOffset = pageToRenderOffset(page);\n    const scrollOffset = safeOffset - renderOffset;\n\n    setScrollState({ scrollOffset, renderOffset, page, scrollDirection });\n    return scrollOffset;\n  }\n\n  return {...scrollState, renderSize, onScroll, doScrollTo} as const;\n}\n\nexport default useVirtualScroll;\n","// Based on https://github.com/realwugang/use-event-listener\n// and https://github.com/donavon/use-event-listener/blob/develop/src/index.js\n\nimport { useRef, useEffect, RefObject, createRef } from 'react';\n\ninterface Options {\n  capture?: boolean\n  once?: boolean\n  passive?: boolean\n};\n\ntype Listener = Window | Document | HTMLElement;\n\nfunction isListener(element: Listener | RefObject<HTMLElement>): element is Listener {\n  return (element as Listener).addEventListener !== undefined;\n}\n\nexport function useEventListener (eventName: string, \n                                  handler: (event: Event) => void, \n                                  element: Listener | RefObject<HTMLElement> | null = window, \n                                  options: Options = {}) {\n  const savedHandler = useRef<any>();\n  const { capture, passive, once } = options;\n\n  useEffect(() => {\n    savedHandler.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    if (!element)\n      return;\n\n    const el =  isListener(element) ? element : element.current;\n    if (!el)\n      return;\n\n    const eventListener = (event: Event) => savedHandler.current(event);\n    const opts = { capture, passive, once };\n    el.addEventListener(eventName, eventListener, opts);\n    return () => {\n      el.removeEventListener(eventName, eventListener, opts);\n    };\n  }, [eventName, element, capture, passive, once]);\n}\n\nexport default useEventListener;\n\n// In-source testing for private helper functions\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('isListener', () => {\n    expect(isListener(window)).toBe(true)\n    expect(isListener(document)).toBe(true)\n    expect(isListener(document.createElement(\"div\"))).toBe(true)\n    expect(isListener(createRef())).toBe(false)\n  })\n}","// Based on https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n// and https://www.joshwcomeau.com/snippets/react-hooks/use-timeout/\n// and https://github.com/bvaughn/react-window/blob/master/src/timer.js\n//\n// Equivalent functionality to a useTimeout hook but based on requestAnimationFrame instead of setTimeout. Use\n// when making frequent requests for short duration timeouts where browser may throttle setTimeout.\nimport { useEffect, useRef } from 'react';\n\ntype Callback = () => void;\n\nexport function useAnimationTimeout(callback: Callback, delay: number | null, key?: unknown) {\n  const requestRef = useRef<number>();\n  const savedCallback = useRef<Callback>(callback);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n \n  const start = performance.now();\n  \n  useEffect(() => {\n    function tick() {\n      requestRef.current = undefined;\n      if (delay === null)\n        return;\n\n      if (performance.now() - start >= delay) {\n        savedCallback.current();\n      } else {\n        requestRef.current = requestAnimationFrame(tick);\n      }\n    }\n\n    tick();\n\n    return () => {\n      if (typeof requestRef.current === 'number') {\n        cancelAnimationFrame(requestRef.current);\n        requestRef.current = undefined;\n      }\n    }\n  }, [delay, key]);\n}\n\nexport default useAnimationTimeout;","import { useState, RefObject } from \"react\";\nimport { useEventListener } from './useEventListener';\nimport { useAnimationTimeout } from './useAnimationTimeout';\n\nconst DEBOUNCE_INTERVAL = 150;\nconst FALLBACK_INTERVAL = 500;\n\nexport function useIsScrolling(element: Window | HTMLElement | RefObject<HTMLElement> | null = window): boolean {\n  const [scrollCount, setScrollCount] = useState(0);\n\n  // scrollend implementations in both Chrome and Firefox are buggy with missing scrollend events\n  // in some circumstances (using keyboard to scroll past end in Chrome, intermittently when using mouse wheel in Firefox)\n  // Use a timeout even when scrollend is supported to handle missing events. In this case we use a longer interval as\n  // don't want it to be over sensitive. \n  const supportsScrollEnd = ('onscrollend' in window);\n  const delay = supportsScrollEnd ? FALLBACK_INTERVAL : DEBOUNCE_INTERVAL;\n\n  useEventListener(\"scroll\", () => setScrollCount(c => c + 1), element);\n  useEventListener(\"scrollend\", () => setScrollCount(0), supportsScrollEnd ? element : null);\n  useAnimationTimeout(() => setScrollCount(0), (scrollCount == 0) ? null : delay, scrollCount);\n\n  return scrollCount > 0;\n}\n\nexport default useIsScrolling;","import React from \"react\";\nimport { Fragment } from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, VirtualBaseProps, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport interface VirtualGridItemProps extends VirtualBaseItemProps {\n  rowIndex: number,\n  columnIndex: number,\n};\n\ntype VirtualGridItem = React.ComponentType<VirtualGridItemProps>;\n\nexport interface VirtualGridProps extends VirtualBaseProps {\n  children: VirtualGridItem,\n  rowCount: number,\n  rowOffsetMapping: ItemOffsetMapping,\n  columnCount: number,\n  columnOffsetMapping: ItemOffsetMapping,\n  itemKey?: (rowIndex: number, columnIndex: number, data: any) => any,\n};\n\nexport interface VirtualGridProxy {\n  scrollTo(rowOffset: number, columnOffset: number): void;\n  scrollToItem(rowIndex: number, columnIndex: number): void;\n};\n\nconst defaultItemKey = (rowIndex: number, columnIndex: number, _data: any) => `${rowIndex}:${columnIndex}`;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualGrid = React.forwardRef<VirtualGridProxy, VirtualGridProps>(function VirtualGrid(props, ref) {\n  const { width, height, rowCount, rowOffsetMapping, columnCount, columnOffsetMapping, children, \n    itemData = undefined, itemKey = defaultItemKey, useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalRowSize = rowOffsetMapping.itemOffset(rowCount);\n  const totalColumnSize = columnOffsetMapping.itemOffset(columnCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset: scrollRowOffset, renderOffset: renderRowOffset, renderSize: renderRowSize,\n    onScroll: onScrollRow, doScrollTo: doScrollToRow } = useVirtualScroll(totalRowSize);\n  const { scrollOffset: scrollColumnOffset, renderOffset: renderColumnOffset, renderSize: renderColumnSize,\n    onScroll: onScrollColumn, doScrollTo: doScrollToColumn} = useVirtualScroll(totalColumnSize);\n  const isScrolling = useIsScrollingHook(outerRef); \n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(rowOffset: number, columnOffset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer)\n          outer.scrollTo(doScrollToColumn(columnOffset, outer.clientWidth), doScrollToRow(rowOffset, outer.clientHeight));\n      },\n\n      scrollToItem(rowIndex: number, columnIndex: number): void {\n        this.scrollTo(rowOffsetMapping.itemOffset(rowIndex), columnOffsetMapping.itemOffset(columnIndex));\n      }\n    }\n  }, [ rowOffsetMapping, columnOffsetMapping ]);\n\n\n  function onScroll(event: ScrollEvent) {\n    const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollLeft, scrollTop } = event.currentTarget;\n    const newScrollTop = onScrollRow(clientHeight, scrollHeight, scrollTop);\n    const newScrollLeft = onScrollColumn(clientWidth, scrollWidth, scrollLeft);\n    if (outerRef.current && (newScrollTop != scrollTop || newScrollLeft != scrollLeft ))\n      outerRef.current.scrollTo(newScrollLeft, newScrollTop);\n  }\n\n  const [startRowIndex, startRowOffset, rowSizes] = \n    getRangeToRender(rowCount, rowOffsetMapping, height, scrollRowOffset + renderRowOffset);\n  const [startColumnIndex, startColumnOffset, columnSizes] = \n    getRangeToRender(columnCount, columnOffsetMapping, width, scrollColumnOffset + renderColumnOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextRowOffset = startRowOffset - renderRowOffset;\n  let rowIndex=0, rowOffset=0;\n  let nextColumnOffset=0, columnIndex=0, columnOffset=0;\n\n  return (\n    <div onScroll={onScroll} ref={outerRef} style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <div style={{ height: renderRowSize, width: renderColumnSize }}>\n        {rowSizes.map((rowSize, rowArrayIndex) => (\n          rowOffset = nextRowOffset,\n          nextRowOffset += rowSize,\n          rowIndex = startRowIndex + rowArrayIndex,\n          nextColumnOffset = startColumnOffset - renderColumnOffset,\n          <Fragment key={itemKey(rowIndex, 0, itemData)}>\n          {columnSizes.map((columnSize, columnArrayIndex) => (\n            columnOffset = nextColumnOffset,\n            nextColumnOffset += columnSize,\n            columnIndex = startColumnIndex + columnArrayIndex,\n            <ChildVar data={itemData} key={itemKey(rowIndex, columnIndex, itemData)}\n                      rowIndex={rowIndex} columnIndex={columnIndex}\n                      isScrolling={useIsScrolling ? isScrolling : undefined}\n                      style={{ position: \"absolute\", top: rowOffset, height: rowSize, left: columnOffset, width: columnSize }}/>\n          ))}\n          </Fragment>\n        ))}\n      </div>\n    </div>\n  );\n});\n\nexport default VirtualGrid;\n","import React from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, VirtualBaseProps, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport type ScrollLayout = \"horizontal\" | \"vertical\";\n\nexport interface VirtualListItemProps extends VirtualBaseItemProps {\n  index: number,\n};\n\ntype VirtualListItem = React.ComponentType<VirtualListItemProps>;\n\nexport interface VirtualListProps extends VirtualBaseProps {\n  children: VirtualListItem,\n  itemCount: number,\n  itemOffsetMapping: ItemOffsetMapping,\n  itemKey?: (index: number, data: any) => any,\n  layout?: ScrollLayout,\n};\n\nexport interface VirtualListProxy {\n  scrollTo(offset: number): void;\n  scrollToItem(index: number): void;\n};\n\nconst defaultItemKey = (index: number, _data: any) => index;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualList = React.forwardRef<VirtualListProxy, VirtualListProps>(function VirtualList(props, ref) {\n  const { width, height, itemCount, itemOffsetMapping, children, \n    itemData = undefined, itemKey = defaultItemKey, layout = 'vertical', useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalSize = itemOffsetMapping.itemOffset(itemCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset, renderOffset, renderSize, onScroll: onScrollExtent, doScrollTo } = useVirtualScroll(totalSize);\n  const isScrolling = useIsScrollingHook(outerRef); \n  const isVertical = layout === 'vertical';\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(offset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer) {\n          if (isVertical)\n            outer.scrollTo(0, doScrollTo(offset, outer.clientHeight));\n          else\n            outer.scrollTo(doScrollTo(offset, outer.clientWidth), 0);\n        }\n      },\n\n      scrollToItem(index: number): void {\n        this.scrollTo(itemOffsetMapping.itemOffset(index));\n      }\n    }\n  }, [ itemOffsetMapping ]);\n\n  function onScroll(event: ScrollEvent) {\n    if (isVertical) {\n      const { clientHeight, scrollHeight, scrollTop, scrollLeft } = event.currentTarget;\n      const newScrollTop = onScrollExtent(clientHeight, scrollHeight, scrollTop);\n      if (newScrollTop != scrollTop && outerRef.current)\n        outerRef.current.scrollTo(scrollLeft, newScrollTop);\n    } else {\n      const { clientWidth, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n      const newScrollLeft = onScrollExtent(clientWidth, scrollWidth, scrollLeft);\n      if (newScrollLeft != scrollLeft && outerRef.current)\n        outerRef.current.scrollTo(newScrollLeft, scrollTop);\n    }\n  }\n\n  const [startIndex, startOffset, sizes] = getRangeToRender(itemCount, itemOffsetMapping, \n    isVertical ? height : width, scrollOffset+renderOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextOffset = startOffset - renderOffset;\n  let index, offset;\n\n  return (\n    <div onScroll={onScroll} ref={outerRef} style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <div style={{ height: isVertical ? renderSize : \"100%\", width: isVertical ? \"100%\" : renderSize }}>\n        {sizes.map((size, arrayIndex) => (\n          offset = nextOffset,\n          nextOffset += size,\n          index = startIndex + arrayIndex,\n          <ChildVar data={itemData} key={itemKey(index, itemData)} index={index}\n            isScrolling={useIsScrolling ? isScrolling : undefined}\n            style={{ \n              position: \"absolute\", \n              top: isVertical ? offset : undefined, \n              left: isVertical ? undefined : offset,\n              height: isVertical ? size : \"100%\", \n              width: isVertical ? \"100%\" : size, \n            }}/>\n        ))}\n      </div>\n    </div>\n  );\n});\n\nexport default VirtualList;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass FixedSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (itemSize: number) {\n    this.fixedItemSize = itemSize;\n  }\n\n  itemSize(_itemIndex: number): number {\n    return this.fixedItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    return itemIndex * this.fixedItemSize;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    const itemIndex = Math.floor(offset / this.fixedItemSize);\n    const startOffset = itemIndex * this.fixedItemSize;\n\n    return [itemIndex, startOffset];\n  }\n\n  fixedItemSize: number;\n};\n\nexport function useFixedSizeItemOffsetMapping(itemSize: number) {\n  return new FixedSizeItemOffsetMapping(itemSize);\n};\n\nexport default useFixedSizeItemOffsetMapping;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass VariableSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (defaultItemSize: number, sizes: number[]) {\n    this.defaultItemSize = defaultItemSize;\n    this.sizes = sizes;\n  }\n\n  itemSize(itemIndex: number): number {\n    return (itemIndex < this.sizes.length) ? this.sizes[itemIndex] : this.defaultItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    var offset = 0;\n    let length = this.sizes.length;\n    if (itemIndex > length) {\n      const numDefaultSize = itemIndex - length;\n      offset = numDefaultSize * this.defaultItemSize;\n    } else {\n      length = itemIndex;\n    }\n    \n    for (let i = 0; i < length; i ++)\n    {\n      offset += this.sizes[i];\n    }\n\n    return offset;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    var startOffset = 0;\n    const length = this.sizes.length;\n    for (let i = 0; i < length; i ++) {\n      const size = this.sizes[i];\n      if (startOffset + size > offset) {\n        return [i, startOffset];\n      }\n      startOffset += size;\n    }\n\n    const itemIndex = Math.floor((offset - startOffset) / this.defaultItemSize);\n    startOffset += itemIndex * this.defaultItemSize;\n\n    return [itemIndex+length, startOffset];\n  }\n\n  defaultItemSize: number;\n  sizes: number[];\n};\n\nexport function useVariableSizeItemOffsetMapping(defaultItemSize: number, sizes?: number[]) {\n  return new VariableSizeItemOffsetMapping(defaultItemSize, sizes || []);\n};\n\nexport default useVariableSizeItemOffsetMapping;"],"names":["getRangeToRender","itemCount","itemOffsetMapping","clientExtent","scrollOffset","itemIndex","startOffset","endOffset","overscanBackward","overscanForward","step","startIndex","offset","sizes","size","MAX_SUPPORTED_CSS_SIZE","MIN_NUMBER_PAGES","useVirtualScroll","totalSize","renderSize","pageSize","numPages","pageToRenderOffset","page","initValue","scrollState","setScrollState","useState","onScroll","scrollExtent","newOffset","newScrollDirection","newPage","newRenderOffset","retScrollOffset","scaleFactor","doScrollTo","safeOffset","scrollDirection","renderOffset","isListener","element","useEventListener","eventName","handler","options","savedHandler","useRef","capture","passive","once","useEffect","el","eventListener","event","opts","it","expect","createRef","useAnimationTimeout","callback","delay","key","requestRef","savedCallback","start","tick","DEBOUNCE_INTERVAL","FALLBACK_INTERVAL","useIsScrolling","scrollCount","setScrollCount","supportsScrollEnd","c","defaultItemKey","rowIndex","columnIndex","_data","VirtualGrid","React","props","ref","width","height","rowCount","rowOffsetMapping","columnCount","columnOffsetMapping","children","itemData","itemKey","totalRowSize","totalColumnSize","outerRef","scrollRowOffset","renderRowOffset","renderRowSize","onScrollRow","doScrollToRow","scrollColumnOffset","renderColumnOffset","renderColumnSize","onScrollColumn","doScrollToColumn","isScrolling","useIsScrollingHook","rowOffset","columnOffset","outer","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollLeft","scrollTop","newScrollTop","newScrollLeft","startRowIndex","startRowOffset","rowSizes","startColumnIndex","startColumnOffset","columnSizes","ChildVar","nextRowOffset","nextColumnOffset","_jsx","rowSize","rowArrayIndex","Fragment","columnSize","columnArrayIndex","index","VirtualList","layout","onScrollExtent","isVertical","nextOffset","arrayIndex","FixedSizeItemOffsetMapping","itemSize","_itemIndex","useFixedSizeItemOffsetMapping","VariableSizeItemOffsetMapping","defaultItemSize","length","i","useVariableSizeItemOffsetMapping"],"mappings":"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"}