{"version":3,"file":"index-BuXbwoVf.js","sources":["../../../../packages/react-virtual-scroll/src/VirtualBase.ts","../../../../packages/react-virtual-scroll/src/useVirtualScroll.ts","../../../../packages/react-virtual-scroll/src/useEventListener.ts","../../../../packages/react-virtual-scroll/src/useAnimationTimeout.ts","../../../../packages/react-virtual-scroll/src/useIsScrolling.ts","../../../../packages/react-virtual-scroll/src/VirtualGrid.tsx","../../../../packages/react-virtual-scroll/src/VirtualList.tsx","../../../../packages/react-virtual-scroll/src/useFixedSizeItemOffsetMapping.ts","../../../../packages/react-virtual-scroll/src/useVariableSizeItemOffsetMapping.ts"],"sourcesContent":["import React from \"react\";\n\nexport interface VirtualBaseItemProps {\n  data: any,\n  isScrolling?: boolean,\n  style: React.CSSProperties,\n};\n\nexport interface VirtualBaseProps {\n  className?: string,\n  innerClassName?: string,\n  height: number,\n  width: number,\n  itemData?: any,\n  useIsScrolling?: boolean,\n  maxCssSize?: number,\n  minNumPages?: number\n};\n\nexport interface VirtualInnerProps {\n  className: string | undefined;\n  children: React.ReactNode;\n  style: React.CSSProperties;\n}\nexport type VirtualInnerComponent = React.ComponentType<VirtualInnerProps>;\n\nexport interface VirtualOuterProps {\n  className: string | undefined;\n  children: React.ReactNode;\n  style: React.CSSProperties;\n  onScroll: (event: ScrollEvent) => void;\n}\nexport type VirtualOuterComponent = React.ComponentType<VirtualOuterProps>;\n\nexport interface ItemOffsetMapping {\n  itemSize(itemIndex: number): number;\n  itemOffset(itemIndex: number): number;\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number];\n};\n\nexport type ScrollEvent = React.SyntheticEvent<HTMLDivElement>;\n\ntype RangeToRender = [\n  startIndex: number,\n  startOffset: number,\n  sizes: number[]\n];\n\nexport function getRangeToRender(itemCount: number, itemOffsetMapping: ItemOffsetMapping, clientExtent: number, scrollOffset: number): RangeToRender {\n  if (itemCount == 0) {\n    return [0, 0, []];\n  }\n\n  var [itemIndex, startOffset] = itemOffsetMapping.offsetToItem(scrollOffset);\n  itemIndex = Math.max(0, Math.min(itemCount - 1, itemIndex));\n  var endOffset = scrollOffset + clientExtent;\n\n  const overscanBackward = 1;\n  const overscanForward = 1;\n\n  for (let step = 0; step < overscanBackward && itemIndex > 0; step ++) {\n    itemIndex --;\n    startOffset -= itemOffsetMapping.itemSize(itemIndex);\n  }\n\n  const startIndex = itemIndex;\n  var offset = startOffset;\n  const sizes: number[] = [];\n\n  while (offset < endOffset && itemIndex < itemCount) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    offset += size;\n    itemIndex ++;\n  }\n\n  for (let step = 0; step < overscanForward && itemIndex < itemCount; step ++) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    itemIndex ++;\n  }\n\n  return [startIndex, startOffset, sizes];\n}\n","import { useState } from \"react\";\n\nexport type ScrollDirection = \"forward\" | \"backward\";\nexport interface ScrollState { \n  scrollOffset: number, \n  renderOffset: number,\n  page: number, \n  scrollDirection: ScrollDirection, \n};\n\nexport interface VirtualScroll extends ScrollState {\n  renderSize: number;\n\n  // Returns updated scrollOffset. Caller should update scroll bar position if different from value passed in. \n  onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState];\n\n  // Scroll to offset in logical space returning offset to update scroll bar position to\n  doScrollTo(offset: number, clientExtent: number): number;\n};\n\n// Max size that is safe across all browsers (Firefox is the limiting factor)\n// SlickGrid tries to dynamically determine limit on other browsers (Chrome will do 30M) but\n// I prefer simplicity of same behavior across all browsers.\nconst MAX_SUPPORTED_CSS_SIZE = 6000000;\nconst MIN_NUMBER_PAGES = 100;\n\nexport function useVirtualScroll(totalSize: number, maxCssSize = MAX_SUPPORTED_CSS_SIZE, minNumberPages = MIN_NUMBER_PAGES): VirtualScroll {\n  let renderSize=0, pageSize=0, numPages=0;\n  if (totalSize < maxCssSize) {\n    // No paging needed\n    renderSize = pageSize = totalSize;\n    numPages = 1;\n  } else {\n    // Break into pages\n    renderSize = maxCssSize;\n    pageSize = renderSize / minNumberPages;\n    numPages = Math.floor(totalSize / pageSize);\n  }\n\n  function pageToRenderOffset(page: number): number {\n    if (page <= 0)\n      return 0;\n\n    if (page >= numPages-1)\n      return totalSize - renderSize;\n\n    return Math.round((page-1) * (totalSize - renderSize) / (numPages - 3));\n  }\n\n  const initValue: ScrollState = { \n    scrollOffset: 0, \n    renderOffset: 0,\n    page: 0,\n    scrollDirection: \"forward\",\n  };\n  const [scrollState, setScrollState] = useState(initValue);\n\n  function onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState] {\n    if (scrollState.scrollOffset == scrollOffset) {\n      // No need to change state if scroll position unchanged\n      return [scrollOffset, scrollState];\n    }\n\n    // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n    let newOffset = Math.max(0, Math.min(scrollOffset, scrollExtent - clientExtent));\n    const newScrollDirection = scrollState.scrollOffset <= newOffset ? 'forward' : 'backward';\n\n    // Switch pages if needed\n    let newPage, newRenderOffset;\n    let retScrollOffset = scrollOffset;\n    const scrollDist = Math.abs(newOffset - scrollState.scrollOffset);\n    if (scrollDist < clientExtent) {\n      // Scrolling part of visible window, don't want to skip items, so can't scale up movement\n      // If we cross page boundary we need to reset scroll bar position back to where it should be at start of page\n      newPage = Math.min(numPages - 1, Math.floor((scrollOffset + scrollState.renderOffset) / pageSize));\n      newRenderOffset = pageToRenderOffset(newPage);\n      if (newPage != scrollState.page) {\n        // Be very intentional about when we ask caller to reset scroll bar\n        // Don't want to trigger event loops\n        newOffset = scrollOffset + scrollState.renderOffset - newRenderOffset;\n        retScrollOffset = newOffset;\n      }\n    } else {\n      // Large scale scrolling, choosing page from a rolodex\n      // First and last page are mapped 1:1 between grid and container\n      if (newOffset < pageSize) {\n        newPage = 0;\n      } else if (newOffset >= renderSize - pageSize) {\n        newPage = numPages - 1;\n      } else {\n        const scaleFactor = (totalSize - pageSize*2) / (renderSize - pageSize*2);\n        newPage = Math.min(numPages - 3, Math.floor((newOffset - pageSize) * scaleFactor / pageSize)) + 1;\n      }\n      newRenderOffset = pageToRenderOffset(newPage);\n    }\n\n    const newScrollState: ScrollState = \n      { scrollOffset: newOffset, renderOffset: newRenderOffset, page: newPage, scrollDirection: newScrollDirection };\n    setScrollState(newScrollState);\n    return [retScrollOffset, newScrollState];\n  }\n\n  function doScrollTo(offset: number, clientExtent: number) {\n    const safeOffset = Math.min(totalSize - clientExtent, Math.max(offset, 0));\n    const scrollDirection = (scrollState.scrollOffset + scrollState.renderOffset) <= safeOffset ? 'forward' : 'backward';\n    const page = Math.min(numPages - 1, Math.floor(safeOffset / pageSize));\n    const renderOffset = pageToRenderOffset(page);\n    const scrollOffset = safeOffset - renderOffset;\n\n    setScrollState({ scrollOffset, renderOffset, page, scrollDirection });\n    return scrollOffset;\n  }\n\n  return {...scrollState, renderSize, onScroll, doScrollTo} as const;\n}\n\nexport default useVirtualScroll;\n","// Based on https://github.com/realwugang/use-event-listener\n// and https://github.com/donavon/use-event-listener/blob/develop/src/index.js\n\nimport { useRef, useEffect, RefObject, createRef } from 'react';\n\ninterface Options {\n  capture?: boolean\n  once?: boolean\n  passive?: boolean\n};\n\ntype Listener = Window | Document | HTMLElement;\n\nfunction isListener(element: Listener | RefObject<HTMLElement>): element is Listener {\n  return (element as Listener).addEventListener !== undefined;\n}\n\nexport function useEventListener (eventName: string, \n                                  handler: (event: Event) => void, \n                                  element: Listener | RefObject<HTMLElement> | null = window, \n                                  options: Options = {}) {\n  const savedHandler = useRef<any>();\n  const { capture, passive, once } = options;\n\n  useEffect(() => {\n    savedHandler.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    if (!element)\n      return;\n\n    const el =  isListener(element) ? element : element.current;\n    if (!el)\n      return;\n\n    const eventListener = (event: Event) => savedHandler.current(event);\n    const opts = { capture, passive, once };\n    el.addEventListener(eventName, eventListener, opts);\n    return () => {\n      el.removeEventListener(eventName, eventListener, opts);\n    };\n  }, [eventName, element, capture, passive, once]);\n}\n\nexport default useEventListener;\n\n// In-source testing for private helper functions\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('isListener', () => {\n    expect(isListener(window)).toBe(true)\n    expect(isListener(document)).toBe(true)\n    expect(isListener(document.createElement(\"div\"))).toBe(true)\n    expect(isListener(createRef())).toBe(false)\n  })\n}","// Based on https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n// and https://www.joshwcomeau.com/snippets/react-hooks/use-timeout/\n// and https://github.com/bvaughn/react-window/blob/master/src/timer.js\n//\n// Equivalent functionality to a useTimeout hook but based on requestAnimationFrame instead of setTimeout. Use\n// when making frequent requests for short duration timeouts where browser may throttle setTimeout.\nimport { useEffect, useRef } from 'react';\n\ntype Callback = () => void;\n\nexport function useAnimationTimeout(callback: Callback, delay: number | null, key?: unknown) {\n  const requestRef = useRef<number>();\n  const savedCallback = useRef<Callback>(callback);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n \n  const start = performance.now();\n  \n  useEffect(() => {\n    function tick() {\n      requestRef.current = undefined;\n      if (delay === null)\n        return;\n\n      if (performance.now() - start >= delay) {\n        savedCallback.current();\n      } else {\n        requestRef.current = requestAnimationFrame(tick);\n      }\n    }\n\n    tick();\n\n    return () => {\n      if (typeof requestRef.current === 'number') {\n        cancelAnimationFrame(requestRef.current);\n        requestRef.current = undefined;\n      }\n    }\n  }, [delay, key]);\n}\n\nexport default useAnimationTimeout;","import { useState, RefObject } from \"react\";\nimport { useEventListener } from './useEventListener';\nimport { useAnimationTimeout } from './useAnimationTimeout';\n\nconst DEBOUNCE_INTERVAL = 150;\nconst FALLBACK_INTERVAL = 500;\n\nexport function useIsScrolling(element: Window | HTMLElement | RefObject<HTMLElement> | null = window): boolean {\n  const [scrollCount, setScrollCount] = useState(0);\n\n  // scrollend implementations in both Chrome and Firefox are buggy with missing scrollend events\n  // in some circumstances (using keyboard to scroll past end in Chrome, intermittently when using mouse wheel in Firefox)\n  // Use a timeout even when scrollend is supported to handle missing events. In this case we use a longer interval as\n  // don't want it to be over sensitive. \n  const supportsScrollEnd = ('onscrollend' in window);\n  const delay = supportsScrollEnd ? FALLBACK_INTERVAL : DEBOUNCE_INTERVAL;\n\n  useEventListener(\"scroll\", () => setScrollCount(c => c + 1), element);\n  useEventListener(\"scrollend\", () => setScrollCount(0), supportsScrollEnd ? element : null);\n  useAnimationTimeout(() => setScrollCount(0), (scrollCount == 0) ? null : delay, scrollCount);\n\n  return scrollCount > 0;\n}\n\nexport default useIsScrolling;","import React from \"react\";\nimport { Fragment } from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, VirtualBaseProps, \n  VirtualInnerComponent, VirtualOuterComponent, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll, ScrollState } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport interface VirtualGridItemProps extends VirtualBaseItemProps {\n  rowIndex: number,\n  columnIndex: number,\n};\n\ntype VirtualGridItem = React.ComponentType<VirtualGridItemProps>;\n\nexport interface VirtualGridProps extends VirtualBaseProps {\n  children: VirtualGridItem,\n  rowCount: number,\n  rowOffsetMapping: ItemOffsetMapping,\n  columnCount: number,\n  columnOffsetMapping: ItemOffsetMapping,\n  itemKey?: (rowIndex: number, columnIndex: number, data: any) => any,\n  onScroll?: (rowOffset: number, columnOffset: number, newRowScrollState: ScrollState, newColumnScrollState: ScrollState) => void;\n  outerComponent?: VirtualOuterComponent;\n  innerComponent?: VirtualInnerComponent;\n};\n\nexport interface VirtualGridProxy {\n  scrollTo(rowOffset: number, columnOffset: number): void;\n  scrollToItem(rowIndex: number, columnIndex: number): void;\n};\n\nconst defaultItemKey = (rowIndex: number, columnIndex: number, _data: any) => `${rowIndex}:${columnIndex}`;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualGrid = React.forwardRef<VirtualGridProxy, VirtualGridProps>(function VirtualGrid(props, ref) {\n  const { width, height, rowCount, rowOffsetMapping, columnCount, columnOffsetMapping, children, className, innerClassName, \n    itemData = undefined, itemKey = defaultItemKey, onScroll: onScrollCallback, useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalRowSize = rowOffsetMapping.itemOffset(rowCount);\n  const totalColumnSize = columnOffsetMapping.itemOffset(columnCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset: scrollRowOffset, renderOffset: renderRowOffset, renderSize: renderRowSize,\n    onScroll: onScrollRow, doScrollTo: doScrollToRow } = useVirtualScroll(totalRowSize, props.maxCssSize, props.minNumPages);\n  const { scrollOffset: scrollColumnOffset, renderOffset: renderColumnOffset, renderSize: renderColumnSize,\n    onScroll: onScrollColumn, doScrollTo: doScrollToColumn} = useVirtualScroll(totalColumnSize, props.maxCssSize, props.minNumPages);\n  const isScrolling = useIsScrollingHook(outerRef); \n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(rowOffset: number, columnOffset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer)\n          outer.scrollTo(doScrollToColumn(columnOffset, outer.clientWidth), doScrollToRow(rowOffset, outer.clientHeight));\n      },\n\n      scrollToItem(rowIndex: number, columnIndex: number): void {\n        this.scrollTo(rowOffsetMapping.itemOffset(rowIndex), columnOffsetMapping.itemOffset(columnIndex));\n      }\n    }\n  }, [ rowOffsetMapping, columnOffsetMapping, doScrollToRow, doScrollToColumn ]);\n\n\n  function onScroll(event: ScrollEvent) {\n    const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollLeft, scrollTop } = event.currentTarget;\n    const [newScrollTop, newRowScrollState] = onScrollRow(clientHeight, scrollHeight, scrollTop);\n    const [newScrollLeft, newColumnScrollState] = onScrollColumn(clientWidth, scrollWidth, scrollLeft);\n    if (outerRef.current && (newScrollTop != scrollTop || newScrollLeft != scrollLeft ))\n      outerRef.current.scrollTo(newScrollLeft, newScrollTop);\n    onScrollCallback?.(newRowScrollState.scrollOffset+newRowScrollState.renderOffset, \n      newColumnScrollState.scrollOffset+newColumnScrollState.renderOffset, newRowScrollState, newColumnScrollState);\n  }\n\n  const [startRowIndex, startRowOffset, rowSizes] = \n    getRangeToRender(rowCount, rowOffsetMapping, height, scrollRowOffset + renderRowOffset);\n  const [startColumnIndex, startColumnOffset, columnSizes] = \n    getRangeToRender(columnCount, columnOffsetMapping, width, scrollColumnOffset + renderColumnOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n  const Outer = props.outerComponent || 'div';\n  const Inner = props.innerComponent || 'div';\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextRowOffset = startRowOffset - renderRowOffset;\n  let rowIndex=0, rowOffset=0;\n  let nextColumnOffset=0, columnIndex=0, columnOffset=0;\n\n  return (\n    <Outer className={className} onScroll={onScroll} ref={outerRef} \n        style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <Inner className={innerClassName} style={{ height: renderRowSize, width: renderColumnSize }}>\n        {rowSizes.map((rowSize, rowArrayIndex) => (\n          rowOffset = nextRowOffset,\n          nextRowOffset += rowSize,\n          rowIndex = startRowIndex + rowArrayIndex,\n          nextColumnOffset = startColumnOffset - renderColumnOffset,\n          <Fragment key={itemKey(rowIndex, 0, itemData)}>\n          {columnSizes.map((columnSize, columnArrayIndex) => (\n            columnOffset = nextColumnOffset,\n            nextColumnOffset += columnSize,\n            columnIndex = startColumnIndex + columnArrayIndex,\n            <ChildVar data={itemData} key={itemKey(rowIndex, columnIndex, itemData)}\n                      rowIndex={rowIndex} columnIndex={columnIndex}\n                      isScrolling={useIsScrolling ? isScrolling : undefined}\n                      style={{ position: \"absolute\", top: rowOffset, height: rowSize, left: columnOffset, width: columnSize }}/>\n          ))}\n          </Fragment>\n        ))}\n      </Inner>\n    </Outer>\n  );\n});\n\nexport default VirtualGrid;\n","import React from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, \n  VirtualBaseProps, VirtualInnerComponent, VirtualOuterComponent, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll, ScrollState } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport type ScrollLayout = \"horizontal\" | \"vertical\";\n\nexport interface VirtualListItemProps extends VirtualBaseItemProps {\n  index: number,\n};\ntype VirtualListItem = React.ComponentType<VirtualListItemProps>;\n\nexport interface VirtualListProps extends VirtualBaseProps {\n  children: VirtualListItem,\n  itemCount: number,\n  itemOffsetMapping: ItemOffsetMapping,\n  itemKey?: (index: number, data: any) => any,\n  layout?: ScrollLayout,\n  onScroll?: (offset: number, newScrollState: ScrollState) => void;\n  outerComponent?: VirtualOuterComponent;\n  innerComponent?: VirtualInnerComponent;\n};\n\nexport interface VirtualListProxy {\n  scrollTo(offset: number): void;\n  scrollToItem(index: number): void;\n};\n\nconst defaultItemKey = (index: number, _data: any) => index;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualList = React.forwardRef<VirtualListProxy, VirtualListProps>(function VirtualList(props, ref) {\n  const { width, height, itemCount, itemOffsetMapping, children, className, innerClassName,\n    itemData = undefined, itemKey = defaultItemKey, layout = 'vertical', onScroll: onScrollCallback, useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalSize = itemOffsetMapping.itemOffset(itemCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset, renderOffset, renderSize, onScroll: onScrollExtent, doScrollTo } = \n    useVirtualScroll(totalSize, props.maxCssSize, props.minNumPages);\n  const isScrolling = useIsScrollingHook(outerRef); \n  const isVertical = layout === 'vertical';\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(offset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer) {\n          if (isVertical)\n            outer.scrollTo(0, doScrollTo(offset, outer.clientHeight));\n          else\n            outer.scrollTo(doScrollTo(offset, outer.clientWidth), 0);\n        }\n      },\n\n      scrollToItem(index: number): void {\n        this.scrollTo(itemOffsetMapping.itemOffset(index));\n      }\n    }\n  }, [ itemOffsetMapping, isVertical, doScrollTo ]);\n\n  function onScroll(event: ScrollEvent) {\n    if (isVertical) {\n      const { clientHeight, scrollHeight, scrollTop, scrollLeft } = event.currentTarget;\n      const [newScrollTop, newScrollState] = onScrollExtent(clientHeight, scrollHeight, scrollTop);\n      if (newScrollTop != scrollTop && outerRef.current)\n        outerRef.current.scrollTo(scrollLeft, newScrollTop);\n      onScrollCallback?.(newScrollState.scrollOffset+newScrollState.renderOffset, newScrollState);\n    } else {\n      const { clientWidth, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n      const [newScrollLeft, newScrollState] = onScrollExtent(clientWidth, scrollWidth, scrollLeft);\n      if (newScrollLeft != scrollLeft && outerRef.current)\n        outerRef.current.scrollTo(newScrollLeft, scrollTop);\n      onScrollCallback?.(newScrollState.scrollOffset+newScrollState.renderOffset, newScrollState);\n    }\n  }\n\n  const [startIndex, startOffset, sizes] = getRangeToRender(itemCount, itemOffsetMapping, \n    isVertical ? height : width, scrollOffset+renderOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do.\n  const ChildVar = children;\n  const Outer = props.outerComponent || 'div';\n  const Inner = props.innerComponent || 'div';\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextOffset = startOffset - renderOffset;\n  let index, offset;\n\n  return (\n    <Outer className={className} onScroll={onScroll} ref={outerRef} \n        style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <Inner className={innerClassName} style={{ height: isVertical ? renderSize : \"100%\", width: isVertical ? \"100%\" : renderSize }}>\n        {sizes.map((size, arrayIndex) => (\n          offset = nextOffset,\n          nextOffset += size,\n          index = startIndex + arrayIndex,\n          <ChildVar data={itemData} key={itemKey(index, itemData)} index={index}\n            isScrolling={useIsScrolling ? isScrolling : undefined}\n            style={{ \n              position: \"absolute\", \n              top: isVertical ? offset : undefined, \n              left: isVertical ? undefined : offset,\n              height: isVertical ? size : \"100%\", \n              width: isVertical ? \"100%\" : size, \n            }}/>\n        ))}\n      </Inner>\n    </Outer>\n  );\n});\n\nexport default VirtualList;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass FixedSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (itemSize: number) {\n    this.fixedItemSize = itemSize;\n  }\n\n  itemSize(_itemIndex: number): number {\n    return this.fixedItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    return itemIndex * this.fixedItemSize;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    const itemIndex = Math.floor(offset / this.fixedItemSize);\n    const startOffset = itemIndex * this.fixedItemSize;\n\n    return [itemIndex, startOffset];\n  }\n\n  fixedItemSize: number;\n};\n\nexport function useFixedSizeItemOffsetMapping(itemSize: number) {\n  return new FixedSizeItemOffsetMapping(itemSize);\n};\n\nexport default useFixedSizeItemOffsetMapping;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass VariableSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (defaultItemSize: number, sizes: number[]) {\n    this.defaultItemSize = defaultItemSize;\n    this.sizes = sizes;\n  }\n\n  itemSize(itemIndex: number): number {\n    return (itemIndex < this.sizes.length) ? this.sizes[itemIndex] : this.defaultItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    var offset = 0;\n    let length = this.sizes.length;\n    if (itemIndex > length) {\n      const numDefaultSize = itemIndex - length;\n      offset = numDefaultSize * this.defaultItemSize;\n    } else {\n      length = itemIndex;\n    }\n    \n    for (let i = 0; i < length; i ++)\n    {\n      offset += this.sizes[i];\n    }\n\n    return offset;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    var startOffset = 0;\n    const length = this.sizes.length;\n    for (let i = 0; i < length; i ++) {\n      const size = this.sizes[i];\n      if (startOffset + size > offset) {\n        return [i, startOffset];\n      }\n      startOffset += size;\n    }\n\n    const itemIndex = Math.floor((offset - startOffset) / this.defaultItemSize);\n    startOffset += itemIndex * this.defaultItemSize;\n\n    return [itemIndex+length, startOffset];\n  }\n\n  defaultItemSize: number;\n  sizes: number[];\n};\n\nexport function useVariableSizeItemOffsetMapping(defaultItemSize: number, sizes?: number[]) {\n  return new VariableSizeItemOffsetMapping(defaultItemSize, sizes || []);\n};\n\nexport default useVariableSizeItemOffsetMapping;"],"names":["getRangeToRender","itemCount","itemOffsetMapping","clientExtent","scrollOffset","itemIndex","startOffset","endOffset","overscanBackward","overscanForward","step","startIndex","offset","sizes","size","MAX_SUPPORTED_CSS_SIZE","MIN_NUMBER_PAGES","useVirtualScroll","totalSize","maxCssSize","minNumberPages","renderSize","pageSize","numPages","pageToRenderOffset","page","initValue","scrollState","setScrollState","useState","onScroll","scrollExtent","newOffset","newScrollDirection","newPage","newRenderOffset","retScrollOffset","scaleFactor","newScrollState","doScrollTo","safeOffset","scrollDirection","renderOffset","isListener","element","useEventListener","eventName","handler","options","savedHandler","useRef","capture","passive","once","useEffect","el","eventListener","event","opts","it","expect","createRef","useAnimationTimeout","callback","delay","key","requestRef","savedCallback","start","tick","DEBOUNCE_INTERVAL","FALLBACK_INTERVAL","useIsScrolling","scrollCount","setScrollCount","supportsScrollEnd","c","defaultItemKey","rowIndex","columnIndex","_data","VirtualGrid","React","props","ref","width","height","rowCount","rowOffsetMapping","columnCount","columnOffsetMapping","children","className","innerClassName","itemData","itemKey","onScrollCallback","totalRowSize","totalColumnSize","outerRef","scrollRowOffset","renderRowOffset","renderRowSize","onScrollRow","doScrollToRow","scrollColumnOffset","renderColumnOffset","renderColumnSize","onScrollColumn","doScrollToColumn","isScrolling","useIsScrollingHook","rowOffset","columnOffset","outer","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollLeft","scrollTop","newScrollTop","newRowScrollState","newScrollLeft","newColumnScrollState","startRowIndex","startRowOffset","rowSizes","startColumnIndex","startColumnOffset","columnSizes","ChildVar","Outer","Inner","nextRowOffset","nextColumnOffset","_jsx","rowSize","rowArrayIndex","Fragment","columnSize","columnArrayIndex","index","VirtualList","layout","onScrollExtent","isVertical","nextOffset","arrayIndex","FixedSizeItemOffsetMapping","itemSize","_itemIndex","useFixedSizeItemOffsetMapping","VariableSizeItemOffsetMapping","defaultItemSize","length","i","useVariableSizeItemOffsetMapping"],"mappings":"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"}