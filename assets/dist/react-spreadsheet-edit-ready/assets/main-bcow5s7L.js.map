{"version":3,"file":"main-bcow5s7L.js","sources":["../../../../packages/react-virtual-scroll/src/VirtualContainer.tsx","../../../../packages/react-virtual-scroll/src/AutoSizer.tsx","../../../../packages/react-virtual-scroll/src/useVirtualScroll.ts","../../../../packages/react-virtual-scroll/src/useEventListener.ts","../../../../packages/react-virtual-scroll/src/useAnimationTimeout.ts","../../../../packages/react-virtual-scroll/src/useIsScrolling.ts","../../../../packages/react-virtual-scroll/src/VirtualScrollProxy.ts","../../../../packages/react-virtual-scroll/src/VirtualScroll.tsx","../../../../packages/react-virtual-scroll/src/VirtualCommon.ts","../../../../packages/react-virtual-scroll/src/DisplayList.tsx","../../../../packages/react-virtual-scroll/src/DisplayGrid.tsx","../../../../packages/react-virtual-scroll/src/VirtualGridProxy.ts","../../../../packages/react-virtual-scroll/src/VirtualGrid.tsx","../../../../packages/react-virtual-scroll/src/VirtualListProxy.ts","../../../../packages/react-virtual-scroll/src/VirtualList.tsx","../../../../packages/react-virtual-scroll/src/useFixedSizeItemOffsetMapping.ts","../../../../packages/react-virtual-scroll/src/useVariableSizeItemOffsetMapping.ts","../../../../packages/react-spreadsheet/src/SpreadsheetData.ts","../../../../packages/react-spreadsheet/src/RowColRef.ts","../../../../packages/react-spreadsheet/src/VirtualSpreadsheetTheme.ts","../../../../packages/react-spreadsheet/src/VirtualSpreadsheet.tsx","../../src/BoringData.ts","../../src/App.tsx","../../src/main.tsx"],"sourcesContent":["import React from \"react\";\n\n/**\n * Props that an implementation of {@link VirtualContainerRender} must accept.\n * \n * Includes all the props that a {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement | HTMLDivElement} would accept.\n */\nexport type VirtualContainerRenderProps = React.ComponentPropsWithoutRef<'div'>;\n\n/**\n * Render prop for a {@link VirtualContainer}\n *\n * Can be passed to {@link VirtualContainer} to replace default implementation. \n * Function must render a div and forward {@link VirtualContainerRenderProps}\n * and any `ref` to it. \n * \n * @example Minimal compliant implementation\n * ```\n * const containerRender: VirtualContainerRender = ({...rest}, ref) => (\n *   <div ref={ref} {...rest} />\n * )\n * ```\n */\nexport type VirtualContainerRender = (props: VirtualContainerRenderProps, ref?: React.ForwardedRef<HTMLDivElement>) => JSX.Element;\n\n/**\n * Props that {@link VirtualContainer} accepts.\n */\nexport interface VirtualContainerComponentProps extends VirtualContainerRenderProps {\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link VirtualContainer}. */\n  render?: VirtualContainerRender;\n}\n\nconst defaultContainerRender: VirtualContainerRender = ({...rest}, ref) => (\n  <div ref={ref} {...rest} />\n)\n\n/**\n * Wrapper around a div used by other components in {@link @candidstartup/react-virtual-scroll!}. Most props are passed through to the div. Use the\n * {@link VirtualContainerComponentProps.render} prop to override the default behavior. \n * \n * @group Components\n */\nexport const VirtualContainer = React.forwardRef<HTMLDivElement, VirtualContainerComponentProps >(\n  function VirtualContainer({render = defaultContainerRender, ...rest}, ref) {\n    return render(rest, ref)\n})\n","import React from \"react\";\n\n/**\n * Props that an implementation of {@link AutoSizerRender} must accept.\n */\nexport interface AutoSizerRenderProps {\n  /** Computed height */\n  height: number,\n\n   /** Computed width */\n  width: number,\n}\n\n/**\n * Render prop for content in an {@link AutoSizer}\n *\n * Function renders content and forwards `width` and `height`\n * to whatever needs it.\n * \n * @example Simple implementation\n * ```\n * const autoSizeRender: AutoSizeRender = ({width, height}) => (\n *   <VirtualList width={width} height={height} {...props} />\n * )\n * ```\n */\nexport type AutoSizerRender = (props: AutoSizerRenderProps) => JSX.Element;\n\n/**\n * Props accepted by {@link AutoSizer}\n */\nexport interface AutoSizerProps {\n  /** Function implementing {@link AutoSizerRender} that renders the content that needs explicit sizing */\n  children: AutoSizerRender\n\n  /** The `className` applied to the container element */\n  className?: string,\n\n  /** Inline style to apply to the container element */\n  style?: React.CSSProperties;\n}\n\n/**\n * HOC that calculates the size available to it and makes the computed size available to children.\n * The size available depends on DOM layout and style applied wherever the AutoSizer finds itself.\n * You will probably want to pass something appropriate via the `className` or `style` props.\n * \n * Accepts props defined by {@link AutoSizerProps}. \n * You must pass a single instance of {@link AutoSizerRender} as a child.\n * @group Components\n */\nexport function AutoSizer(props: AutoSizerProps) {\n  const { children, className, style } = props;\n\n  // Using separate primitive states rather than one composite so that React\n  // can detect duplicates values and bail out of redundant renders.\n  const [width, setWidth] = React.useState<number>(0);\n  const [height, setHeight] = React.useState<number>(0);\n  const ref = React.useRef<HTMLDivElement>(null);\n\n  // Make sure resize callback is a stable value so we're not constantly\n  // creating and disconnecting resize observers.\n  const resizeCallback: ResizeObserverCallback = React.useCallback((entries) => {\n    entries.forEach(entry => {\n      // Context box sizes can contain fractional values while clientWidth\n      // and clientHeight properties are always rounded to nearest integer.\n      // Always use integer values to avoid confusion.\n      const newWidth = Math.round(entry.contentBoxSize[0].inlineSize);\n      setWidth(newWidth);\n      const newHeight = Math.round(entry.borderBoxSize[0].blockSize);\n      setHeight(newHeight);\n    })\n  }, []);\n\n  // Expect effect to run only on initial mount\n  React.useLayoutEffect(() => {\n    const div = ref.current;\n     /* istanbul ignore if*/\n    if (!div)\n      return;\n\n    // Size on initial mount\n    setHeight(div.clientHeight);\n    setWidth(div.clientWidth);\n\n    // Updates size on any subsequent resize. Only available in browser\n    // environment so avoid crashing out when server side rendering, or\n    // running unit test without ResizeObserver being mocked. \n    if (typeof ResizeObserver !== 'undefined') {\n      const resizeObserver = new ResizeObserver(resizeCallback);\n      resizeObserver.observe(div);\n      return () => { resizeObserver.disconnect() }\n    }\n  }, [resizeCallback])\n\n  // No point rendering children until we've measured size and found a usable area\n  const renderChildren = height > 0 && width > 0;\n\n  // Ensure that size is driven only by parent. Wrapping child in a zero sized inner div\n  // which it can overflow stops child's size having any impact on size of outer div. \n  // Otherwise can end up in infinite loop if child makes itself bigger than the \n  // actual width and height we pass to it. That could be because child has \n  // padding/borders/margins or because child renders itself bigger than size it's given.\n  return (\n    <div ref={ref} className={className} style={style}>\n      <div style={{ overflow: 'visible', width: 0, height: 0 }}>\n      {renderChildren && children({height, width})}\n      </div>\n    </div>\n  );\n}\n\nexport default AutoSizer;\n","import { useState, useRef, RefObject } from \"react\";\n\n/** Direction of scrolling */\nexport type ScrollDirection = \"forward\" | \"backward\";\n\n/**\n * Overall scroll state for a single dimension.\n */\nexport interface ScrollState { \n  /** Scroll bar offset. Equal to outer container's `scrollTop` or `scrollLeft` depending on dimension.  */\n  scrollOffset: number, \n\n  /** Offset used to position current page of items in virtual space. Total offset is `scrollOffset+renderOffset`. */\n  renderOffset: number,\n\n  /** Index of current page. */\n  page: number, \n\n  /** Current scrolling direction. Calculated by comparing current overall offset to that when last rendered. */\n  scrollDirection: ScrollDirection, \n}\n\nexport interface VirtualScrollState {\n  /** Snapshot of overall offset at last render */\n  totalOffset: number;\n\n  /** Physical size of scrollable area */\n  renderSize: number;\n\n  // Returns updated scrollOffset. Caller should update scroll bar position if different from value passed in. \n  onScroll(this: void, clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState];\n\n  // Scroll to offset in logical space returning offset to update scroll bar position to\n  doScrollTo(this: void, offset: number, clientExtent: number): number;\n\n  // Returns current overall offset (NOT a snapshot)\n  getCurrentOffset(this: void): number;\n\n  // Internal scroll state. Most scenarios will never need to access this. Mainly here for unit test.\n  scrollState: RefObject<ScrollState>;\n}\n\n// Max size that is safe across all browsers (Firefox is the limiting factor)\n// SlickGrid tries to dynamically determine limit on other browsers (Chrome will do 30M) but\n// I prefer simplicity of same behavior across all browsers.\nconst MAX_SUPPORTED_CSS_SIZE = 6000000;\nconst MIN_NUMBER_PAGES = 100;\n\n/** Custom hook that implements logic for paged virtual scrolling in a single dimension */\nexport function useVirtualScroll(totalSize: number, maxCssSize = MAX_SUPPORTED_CSS_SIZE, minNumberPages = MIN_NUMBER_PAGES, \n                                 useTotalOffset = true): VirtualScrollState {\n  let renderSize=0, pageSize=0, numPages=0;\n  if (totalSize < maxCssSize) {\n    // No paging needed\n    renderSize = pageSize = totalSize;\n    numPages = 1;\n  } else {\n    // Break into pages\n    renderSize = maxCssSize;\n    pageSize = renderSize / minNumberPages;\n    numPages = Math.floor(totalSize / pageSize);\n  }\n\n  function pageToRenderOffset(page: number): number {\n    if (page <= 0)\n      return 0;\n\n    if (page >= numPages-1)\n      return totalSize - renderSize;\n\n    return Math.round((page-1) * (totalSize - renderSize) / (numPages - 3));\n  }\n\n  const initValue: ScrollState = { \n    scrollOffset: 0, \n    renderOffset: 0,\n    page: 0,\n    scrollDirection: \"forward\",\n  };\n  const [totalOffset, setTotalOffset] = useState<number>(0);\n  const scrollState = useRef(initValue);\n\n  function onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState] {\n    const currState = scrollState.current;\n    if (currState.scrollOffset == scrollOffset) {\n      // No need to change state if scroll position unchanged\n      return [scrollOffset, currState];\n    }\n\n    // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n    let newOffset = Math.max(0, Math.min(scrollOffset, scrollExtent - clientExtent));\n    const newScrollDirection = currState.scrollOffset <= newOffset ? 'forward' : 'backward';\n\n    // Switch pages if needed\n    let newPage, newRenderOffset;\n    let retScrollOffset = scrollOffset;\n    const scrollDist = Math.abs(newOffset - currState.scrollOffset);\n    if (scrollDist < clientExtent) {\n      // Scrolling part of visible window, don't want to skip items, so can't scale up movement\n      // If we cross page boundary we need to reset scroll bar position back to where it should be at start of page\n      newPage = Math.min(numPages - 1, Math.floor((scrollOffset + currState.renderOffset) / pageSize));\n      newRenderOffset = pageToRenderOffset(newPage);\n      if (newPage != currState.page) {\n        // Be very intentional about when we ask caller to reset scroll bar\n        // Don't want to trigger event loops\n        newOffset = scrollOffset + currState.renderOffset - newRenderOffset;\n        retScrollOffset = newOffset;\n      }\n    } else {\n      // Large scale scrolling, choosing page from a rolodex\n      // First and last page are mapped 1:1 between grid and container\n      if (newOffset < pageSize) {\n        newPage = 0;\n      } else if (newOffset >= renderSize - pageSize) {\n        newPage = numPages - 1;\n      } else {\n        const scaleFactor = (totalSize - pageSize*2) / (renderSize - pageSize*2);\n        newPage = Math.min(numPages - 3, Math.floor((newOffset - pageSize) * scaleFactor / pageSize)) + 1;\n      }\n      newRenderOffset = pageToRenderOffset(newPage);\n    }\n\n    const newScrollState: ScrollState = \n      { scrollOffset: newOffset, renderOffset: newRenderOffset, page: newPage, scrollDirection: newScrollDirection };\n    scrollState.current = newScrollState;\n    if (useTotalOffset)\n      setTotalOffset(newOffset + newRenderOffset);\n    return [retScrollOffset, newScrollState];\n  }\n\n  function doScrollTo(offset: number, clientExtent: number) {\n    const currState = scrollState.current;\n    const safeOffset = Math.min(totalSize - clientExtent, Math.max(offset, 0));\n    const scrollDirection = (currState.scrollOffset + currState.renderOffset) <= safeOffset ? 'forward' : 'backward';\n    const page = Math.min(numPages - 1, Math.floor(safeOffset / pageSize));\n    const renderOffset = pageToRenderOffset(page);\n    const scrollOffset = safeOffset - renderOffset;\n\n    scrollState.current = { scrollOffset, renderOffset, page, scrollDirection };\n    if (useTotalOffset)\n      setTotalOffset(scrollOffset + renderOffset);\n    return scrollOffset;\n  }\n\n  function getCurrentOffset() {\n    const currState = scrollState.current;\n    return currState.scrollOffset + currState.renderOffset;\n  }\n\n  return {totalOffset, renderSize, onScroll, doScrollTo, getCurrentOffset, scrollState} as const;\n}\n\nexport default useVirtualScroll;\n","// Based on https://github.com/realwugang/use-event-listener\n// and https://github.com/donavon/use-event-listener/blob/develop/src/index.js\n\nimport { useRef, useEffect, RefObject, createRef } from 'react';\n\ninterface Options {\n  capture?: boolean\n  once?: boolean\n  passive?: boolean\n}\n\ntype Listener = Window | Document | HTMLElement;\n\nfunction isListener(element: Listener | RefObject<HTMLElement>): element is Listener {\n  return (element as Listener).addEventListener !== undefined;\n}\n\ntype EventHandler = (event: Event) => void;\n\nexport function useEventListener (eventName: string, \n                                  handler: EventHandler, \n                                  element: Listener | RefObject<HTMLElement> | null = window, \n                                  options: Options = {}) {\n  const savedHandler = useRef<EventHandler>();\n  const { capture, passive, once } = options;\n\n  useEffect(() => {\n    savedHandler.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    if (!element)\n      return;\n\n    const el =  isListener(element) ? element : element.current;\n    if (!el)\n      return;\n\n    const eventListener = (event: Event) => savedHandler.current?.(event);\n    const opts = { capture, passive, once };\n    el.addEventListener(eventName, eventListener, opts);\n    return () => {\n      el.removeEventListener(eventName, eventListener, opts);\n    };\n  }, [eventName, element, capture, passive, once]);\n}\n\nexport default useEventListener;\n\n// In-source testing for private helper functions\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('isListener', () => {\n    expect(isListener(window)).toBe(true)\n    expect(isListener(document)).toBe(true)\n    expect(isListener(document.createElement(\"div\"))).toBe(true)\n    expect(isListener(createRef())).toBe(false)\n  })\n}","// Based on https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n// and https://www.joshwcomeau.com/snippets/react-hooks/use-timeout/\n// and https://github.com/bvaughn/react-window/blob/master/src/timer.js\n//\n// Equivalent functionality to a useTimeout hook but based on requestAnimationFrame instead of setTimeout. Use\n// when making frequent requests for short duration timeouts where browser may throttle setTimeout.\nimport { useEffect, useRef } from 'react';\n\ntype Callback = () => void;\n\nexport function useAnimationTimeout(callback: Callback, delay: number | null, key?: unknown) {\n  const requestRef = useRef<number>();\n  const savedCallback = useRef<Callback>(callback);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n \n  const start = performance.now();\n  \n  useEffect(() => {\n    function tick() {\n      requestRef.current = undefined;\n      if (delay === null)\n        return;\n\n      if (performance.now() - start >= delay) {\n        savedCallback.current();\n      } else {\n        requestRef.current = requestAnimationFrame(tick);\n      }\n    }\n\n    tick();\n\n    return () => {\n      if (typeof requestRef.current === 'number') {\n        cancelAnimationFrame(requestRef.current);\n        requestRef.current = undefined;\n      }\n    }\n  }, [start, delay, key]);\n}\n\nexport default useAnimationTimeout;","import { useState, RefObject } from \"react\";\nimport { useEventListener } from './useEventListener';\nimport { useAnimationTimeout } from './useAnimationTimeout';\n\nconst DEBOUNCE_INTERVAL = 150;\nconst FALLBACK_INTERVAL = 500;\n\nexport function useIsScrolling(element: Window | HTMLElement | RefObject<HTMLElement> | null = window): boolean {\n  const [scrollCount, setScrollCount] = useState(0);\n\n  // scrollend implementations in both Chrome and Firefox are buggy with missing scrollend events\n  // in some circumstances (using keyboard to scroll past end in Chrome, intermittently when using mouse wheel in Firefox)\n  // Use a timeout even when scrollend is supported to handle missing events. In this case we use a longer interval as\n  // don't want it to be over sensitive. \n  const supportsScrollEnd = ('onscrollend' in window);\n  const delay = supportsScrollEnd ? FALLBACK_INTERVAL : DEBOUNCE_INTERVAL;\n\n  useEventListener(\"scroll\", () => setScrollCount(c => c + 1), element);\n  useEventListener(\"scrollend\", () => setScrollCount(0), supportsScrollEnd ? element : null);\n  useAnimationTimeout(() => setScrollCount(0), (scrollCount == 0) ? null : delay, scrollCount);\n\n  return scrollCount > 0;\n}\n\nexport default useIsScrolling;","import { ScrollToOption } from './VirtualBase';\n\n/**\n * Custom ref handle returned by {@link VirtualScroll} that exposes imperative methods\n * \n * Use `React.useRef<VirtualScrollProxy>(null)` to create a ref.\n */\nexport interface VirtualScrollProxy {\n  /**\n   * Scrolls to the specified vertical and horizontal offset in pixels\n   * Either offset can be left undefined to scroll in one dimension only\n   * @param verticalOffset - Offset to scroll to vertically\n   * @param horizontalOffset - Offset to scroll to horizontally\n   */\n  scrollTo(verticalOffset?: number, horizontalOffset?: number): void;\n\n    /**\n   * Scrolls to the specified area\n   * Either offset/size pair can be left undefined to scroll in one dimension only\n   * @param verticalOffset - Offset to scroll to vertically\n   * @param verticalSize - Size of target area vertically\n   * @param horizontalOffset - Offset to scroll to horizontally\n   * @param horizontalSize - Size of target area horizontally\n   * @param option - Where to {@link ScrollToOption | position} the area within the viewport\n   */\n  scrollToArea(verticalOffset?: number, verticalSize?: number, horizontalOffset?: number, horizontalSize?: number, option?: ScrollToOption): void;\n\n  /** Exposes DOM clientWidth property */\n  get clientWidth(): number;\n\n  /** Exposes DOM clientHeight property */\n  get clientHeight(): number;\n\n  /** Current vertical position of scroll bar */\n  get verticalOffset(): number;\n\n    /** Current horizontal position of scroll bar */\n  get horizontalOffset(): number;\n}\n\n/**\n * Returns the offset needed to scroll in one dimension for a specified range\n * \n * Used internally to implement {@link VirtualScrollProxy.scrollToArea}. Can be used directly for \n * advanced customization scenarios.\n */\nexport function getOffsetToScrollRange(offset: number | undefined, size: number | undefined, \n  clientExtent: number, scrollOffset: number, option?: ScrollToOption): number | undefined\n{\n  if (offset === undefined)\n    return undefined;\n\n  if (option != 'visible')\n    return offset;\n\n  // Start of item offscreen before start of viewport?\n  if (offset < scrollOffset)\n    return offset;\n\n  size = size || 0;\n\n  // Already completely visible?\n  const endOffset = offset + size;\n  const endViewport = scrollOffset + clientExtent;\n  if (endOffset <= endViewport)\n    return undefined;\n\n  // Item offscreen past end of viewport\n\n  // Item bigger than viewport? Make sure start is in view\n  if (size > clientExtent)\n    return offset;\n\n  // Scroll so end of item aligns with end of viewport\n  return offset - clientExtent + size;\n }\n","import React from \"react\";\nimport { VirtualContainer, VirtualContainerRender } from './VirtualContainer';\nimport { VirtualScrollableProps, ScrollEvent, ScrollToOption } from './VirtualBase';\nimport { useVirtualScroll, ScrollState } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\nimport { getOffsetToScrollRange, VirtualScrollProxy } from './VirtualScrollProxy';\n\n/**\n * Props that an implementation of {@link VirtualContentRender} must accept.\n */\nexport interface VirtualContentProps {\n  /** \n   * Is the owning component being actively scrolled? Used to change how the content is rendered depending on scroll state.\n   * \n   * Only defined if {@link VirtualScrollableProps.useIsScrolling} is true. \n   * */\n  isScrolling?: boolean,\n\n  /** Current scroll position vertical offset */\n  verticalOffset: number,\n\n    /** Current scroll position horizontal offset */\n  horizontalOffset: number\n}\n\n/**\n * Render prop for content container in {@link VirtualScroll}\n *\n * Pass to {@link VirtualScroll} to render content into the viewport\n * implementation. Function must render a div and forward {@link VirtualContentProps}\n * and any `ref` to it. \n * \n * @example Minimal compliant implementation\n * ```\n * const contentRender: VirtualContentRender = ({isScrolling, ...rest}, ref) => (\n *   <div ref={ref} {...rest} />\n * )\n * ```\n */\nexport type VirtualContentRender = (props: VirtualContentProps, ref?: React.ForwardedRef<HTMLDivElement>) => JSX.Element;\n\n/**\n * Props accepted by {@link VirtualScroll}\n */\nexport interface VirtualScrollProps extends VirtualScrollableProps {\n  /** Function implementing {@link VirtualContentRender} that renders the content that needs to respond to scrolling */\n  children: VirtualContentRender\n\n  /** \n   * Height of area to scroll over \n   * \n   * @defaultValue 0\n   */\n  scrollHeight?: number,\n\n  /** \n   * Width of area to scroll over \n   * \n   * @defaultValue 0\n   */\n  scrollWidth?: number,\n\n  /** \n   * Determines whether the component should pass {@link VirtualContentProps.verticalOffset|verticalOffset} and \n   * {@link VirtualContentProps.horizontalOffset|horizontalOffset} to children when rendering.\n   * \n   * Can reduce the number of renders needed if these props aren't used\n   * \n   * @defaultValue true\n   * */\n  useOffsets?: boolean,\n\n  /**\n   * Callback after a scroll event has been processed and state updated but before rendering\n   * @param verticalOffset - Resulting overall vertical offset. \n   * @param horizontalOffset - Resulting overall horizontal offset.\n   * @param newVerticalScrollState - New vertical {@link ScrollState} that will be used for rendering.\n   * @param newHorizontalScrollState - New horizontal {@link ScrollState} that will be used for rendering.\n   */\n  onScroll?: (verticalOffset: number, horizontalOffset: number, newVerticalScrollState: ScrollState, newHorizontalScrollState: ScrollState) => void;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link VirtualScroll} outer container. */\n  outerRender?: VirtualContainerRender;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link VirtualScroll} inner container. */\n  innerRender?: VirtualContainerRender;\n}\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\n/**\n * Customizable Virtual Scrolling Component\n * \n * Allows user to scroll over a virtual area `scrollHeight` x `scrollWidth` pixels. \n * Use `onScroll` to track scroll state and `innerRender` to render scroll state specific content into the viewport\n * \n * Accepts props defined by {@link VirtualScrollProps}. \n * Refs are forwarded to {@link VirtualScrollProxy}. \n * @group Components\n */\nexport const VirtualScroll = React.forwardRef<VirtualScrollProxy, VirtualScrollProps>(function VirtualScroll(props, ref) {\n  const { width, height, scrollWidth = 0, scrollHeight = 0, className, innerClassName, children,\n    onScroll: onScrollCallback, useIsScrolling = false, useOffsets = true, innerRender, outerRender } = props;\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { totalOffset: currentVerticalOffset, renderSize: renderRowSize, onScroll: onScrollRow,\n    doScrollTo: doScrollToRow, getCurrentOffset: getVerticalOffset } = useVirtualScroll(scrollHeight, props.maxCssSize, props.minNumPages, useOffsets);\n  const { totalOffset: currentHorizontalOffset, renderSize: renderColumnSize, onScroll: onScrollColumn,\n    doScrollTo: doScrollToColumn, getCurrentOffset: getHorizontalOffset} = useVirtualScroll(scrollWidth, props.maxCssSize, props.minNumPages, useOffsets);\n  const isActuallyScrolling = useIsScrollingHook(outerRef);\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(rowOffset?: number, columnOffset?: number): void {\n        if (rowOffset === undefined && columnOffset === undefined)\n          return;\n\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer) {\n          const options: ScrollToOptions = {};\n          if (rowOffset != undefined)\n            options.top = doScrollToRow(rowOffset, outer.clientHeight);\n          if (columnOffset != undefined)\n            options.left = doScrollToColumn(columnOffset, outer.clientWidth);\n          outer.scrollTo(options);\n        }\n      },\n\n      scrollToArea(verticalOffset?: number, verticalSize?: number, horizontalOffset?: number, horizontalSize?: number, option?: ScrollToOption) {\n        const outer = outerRef.current;\n        /* istanbul ignore if*/\n        if (!outer)\n          return;\n\n        const rowOffset = getOffsetToScrollRange(verticalOffset, verticalSize, outer.clientHeight, currentVerticalOffset, option);\n        const colOffset = getOffsetToScrollRange(horizontalOffset, horizontalSize, outer.clientWidth, currentHorizontalOffset, option);\n        this.scrollTo(rowOffset, colOffset);\n      },\n\n      get clientWidth(): number {\n        return outerRef.current ? outerRef.current.clientWidth : /* istanbul ignore next */ 0;\n      },\n\n      get clientHeight(): number {\n        return outerRef.current ? outerRef.current.clientHeight : /* istanbul ignore next */ 0;\n      },\n\n      get verticalOffset(): number { return getVerticalOffset(); },\n\n      get horizontalOffset(): number { return getHorizontalOffset(); }\n    }\n  }, [ doScrollToRow, doScrollToColumn, currentVerticalOffset, currentHorizontalOffset, getVerticalOffset, getHorizontalOffset ]);\n\n  function onScroll(event: ScrollEvent) {\n    const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollLeft, scrollTop } = event.currentTarget;\n    const [newScrollTop, newRowScrollState] = onScrollRow(clientHeight, scrollHeight, scrollTop);\n    const [newScrollLeft, newColumnScrollState] = onScrollColumn(clientWidth, scrollWidth, scrollLeft);\n    if (outerRef.current && (newScrollTop != scrollTop || newScrollLeft != scrollLeft ))\n      outerRef.current.scrollTo(newScrollLeft, newScrollTop);\n    onScrollCallback?.(newRowScrollState.scrollOffset+newRowScrollState.renderOffset, \n      newColumnScrollState.scrollOffset+newColumnScrollState.renderOffset, newRowScrollState, newColumnScrollState);\n  }\n\n  const isScrolling = useIsScrolling ? isActuallyScrolling : undefined;\n  const verticalOffset = currentVerticalOffset;\n  const horizontalOffset = currentHorizontalOffset;\n\n  return (\n    <VirtualContainer className={className} render={outerRender} onScroll={onScroll} ref={outerRef} \n        style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <VirtualContainer className={innerClassName} render={innerRender} \n        style={{ zIndex: 1, position: 'sticky', top: 0, left: 0, width: '100%', height: '100%' }}>\n        {children({isScrolling, verticalOffset, horizontalOffset})}\n      </VirtualContainer>\n      <div style={{ position: 'absolute', top: 0, left: 0, \n        height: scrollHeight ? renderRowSize : '100%', \n        width: scrollWidth ? renderColumnSize : '100%'}}/>\n    </VirtualContainer>\n  );\n});\n\nexport default VirtualScroll;\n","import type { ItemOffsetMapping } from \"./VirtualBase\";\n\ntype RangeToRender = [\n  startIndex: number,\n  startOffset: number,\n  totalSize: number,\n  sizes: number[]\n];\n\nexport function getRangeToRender(itemCount: number, itemOffsetMapping: ItemOffsetMapping, clientExtent: number, scrollOffset: number): RangeToRender {\n  if (itemCount == 0) {\n    return [0, 0, 0, []];\n  }\n\n  // Negative offset equivalent to reducing the size of the window (possibly down to nothing)\n  if (scrollOffset < 0) {\n    clientExtent += scrollOffset;\n    scrollOffset = 0;\n  }\n\n  if (clientExtent <= 0) {\n    return [0, 0, 0, []];\n  }\n\n  const [baseIndex, startOffset] = itemOffsetMapping.offsetToItem(scrollOffset);\n  if (baseIndex >= itemCount) {\n    return [0, 0, 0, []];\n  }\n\n  let itemIndex = Math.max(0, Math.min(itemCount - 1, baseIndex));\n  const endOffset = scrollOffset + clientExtent;\n\n  const startIndex = itemIndex;\n  let offset = startOffset;\n  const sizes: number[] = [];\n  let totalSize = 0;\n\n  while (offset < endOffset && itemIndex < itemCount) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    totalSize += size;\n    offset += size;\n    itemIndex ++;\n  }\n\n  return [startIndex, startOffset, totalSize, sizes];\n}\n\nfunction formatRepeat(repeat: number, size: number): string {\n  return (repeat == 1) ? `${size}px` : `repeat(${repeat},${size}px)`;\n}\n\nfunction join(a: string|undefined, s: string) {\n  return a ? a + ' ' + s : s;\n}\n\nexport function getGridTemplate(sizes: number[]): string | undefined {\n  const count = sizes.length;\n  if (count == 0)\n    return undefined;\n\n  let ret = undefined;\n  let lastSize = sizes[0];\n  let repeat = 1;\n\n  for (let i = 1; i < count; i ++) {\n    const size = sizes[i];\n    if (size == lastSize) {\n      repeat ++;\n    } else {\n      const s = formatRepeat(repeat, lastSize);\n      ret = join(ret,s);\n      lastSize = size;\n      repeat = 1;\n    }\n  }\n\n  const s = formatRepeat(repeat, lastSize);\n  return join(ret,s);\n}\n\n\n","import React from \"react\";\nimport { ItemOffsetMapping, ScrollLayout, DisplayBaseItemProps, DisplayBaseProps } from './VirtualBase';\nimport { getRangeToRender, getGridTemplate } from './VirtualCommon';\nimport { VirtualContainer } from './VirtualContainer';\n\n/**\n * Props accepted by {@link DisplayListItem}\n */\nexport interface DisplayListItemProps extends DisplayBaseItemProps {\n  /** Index of item in the list being rendered */\n  index: number,\n}\n\n/**\n * Type of item in a {@link DisplayList}\n *\n * Must be passed as a child to {@link DisplayList}. \n * Accepts props defined by {@link DisplayListItemProps}.\n * Component must pass {@link DisplayBaseItemProps.style} to whatever it renders. \n * \n * @example Basic implementation\n * ```\n * const Row = ({ index, style }: { index: number, style: React.CSSProperties }) => (\n *   <div className=\"row\" style={style}>\n *     { index }\n *   </div>\n * );\n * ```\n */\nexport type DisplayListItem = React.ComponentType<DisplayListItemProps>;\n\n/**\n * Props accepted by {@link DisplayList}\n */\nexport interface DisplayListProps extends DisplayBaseProps {\n  /** Component used as a template to render items in the list. Must implement {@link DisplayListItem} interface. */\n  children: DisplayListItem,\n\n  /** Number of items in the list */\n  itemCount: number,\n\n  /** Offset to start of displayed content */\n  offset: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each item in the list\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  itemOffsetMapping: ItemOffsetMapping,\n\n  /**\n   * Function that defines the key to use for each item given item index and value of {@link DisplayBaseProps.itemData}.\n   * @defaultValue `(index, _data) => index`\n   */\n  itemKey?: (index: number, data: unknown) => React.Key,\n\n  /**\n   * Choice of 'vertical' or 'horizontal' layouts\n   * @defaultValue 'vertical'\n   */\n  layout?: ScrollLayout,\n}\n\nconst defaultItemKey = (index: number, _data: unknown) => index;\n\nconst boxStyle: React.CSSProperties = { boxSizing: 'border-box' };\n\n/**\n * Displays a window onto the contents of a virtualized list starting from `offset`.\n * \n * Accepts props defined by {@link DisplayListProps}. \n * You must pass a single instance of {@link DisplayListItem} as a child.\n * @group Components\n */\nexport function DisplayList(props: DisplayListProps) {\n  const { width, height, itemCount, itemOffsetMapping, className, innerClassName, offset: renderOffset, children,\n    itemData, itemKey = defaultItemKey, layout = 'vertical', outerRender, innerRender, isScrolling } = props;\n\n  const isVertical = layout === 'vertical';\n\n  const [startIndex, startOffset, renderSize, sizes] = getRangeToRender(itemCount, itemOffsetMapping, \n    isVertical ? height : width, renderOffset);\n  const template = getGridTemplate(sizes);\n  const offset = startOffset - renderOffset;\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do.\n  const ChildVar = children;\n\n  return (\n   <VirtualContainer className={className} render={outerRender}\n        style={{ position: \"relative\", height, width, overflow: \"hidden\", willChange: \"transform\" }}>\n       <VirtualContainer className={innerClassName} render={innerRender}\n        style={{ position: 'absolute',\n          display: 'grid',\n          gridTemplateColumns: isVertical ? undefined : template,\n          gridTemplateRows: isVertical ? template : undefined,\n          top: isVertical ? offset : 0, \n          left: isVertical ? 0 : offset, \n          height: isVertical ? renderSize : \"100%\", \n          width: isVertical ? \"100%\" : renderSize }}>\n        {sizes.map((_size, arrayIndex) => (\n          <ChildVar data={itemData} isScrolling={isScrolling} \n            key={itemKey(startIndex + arrayIndex, itemData)} index={startIndex + arrayIndex} style={boxStyle}/>\n        ))}\n      </VirtualContainer>\n    </VirtualContainer>\n  );\n}\n\nexport default DisplayList;\n","import React, { Fragment } from \"react\";\nimport { ItemOffsetMapping, DisplayBaseItemProps, DisplayBaseProps } from './VirtualBase';\nimport { getRangeToRender, getGridTemplate } from './VirtualCommon';\nimport { VirtualContainer } from './VirtualContainer';\n\n/**\n * Props accepted by {@link DisplayGridItem}\n */\nexport interface DisplayGridItemProps extends DisplayBaseItemProps {\n  /** Row index of item in the grid being rendered */\n  rowIndex: number,\n\n  /** Column index of item in the grid being rendered */\n  columnIndex: number,\n}\n\n/**\n * Type of item in a {@link DisplayGrid}\n *\n * Must be passed as a child to {@link DisplayGrid}. \n * Accepts props defined by {@link DisplayGridItemProps}.\n * Component must pass {@link DisplayBaseItemProps.style} to whatever it renders. \n * \n * @example Basic implementation\n * ```\n * const Row = ({ index, style }: { index: number, style: React.CSSProperties }) => (\n *   <div className=\"row\" style={style}>\n *     { index }\n *   </div>\n * );\n * ```\n */\nexport type DisplayGridItem = React.ComponentType<DisplayGridItemProps>;\n\n/**\n * Props accepted by {@link DisplayGrid}\n */\nexport interface DisplayGridProps extends DisplayBaseProps {\n  /** Component used as a template to render items in the list. Must implement {@link DisplayGridItem} interface. */\n  children: DisplayGridItem,\n\n  /** Number of rows in the grid */\n  rowCount: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each row in the grid\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  rowOffsetMapping: ItemOffsetMapping,\n\n  /** Number of columns in the grid */\n  columnCount: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each column in the grid\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  columnOffsetMapping: ItemOffsetMapping,\n\n  /** Vertical offset to start of displayed content */\n  rowOffset: number,\n\n  /** Horizontal offset to start of displayed content */\n  columnOffset: number,\n\n  /**\n   * Function that defines the key to use for each item given row and column index and value of {@link DisplayBaseProps.itemData}.\n   * @defaultValue\n   * ```ts\n   * (rowIndex, columnIndex, _data) => `${rowIndex}:${columnIndex}`\n   * ```\n   */\n  itemKey?: (rowIndex: number, columnIndex: number, data: unknown) => React.Key,\n}\n\nconst defaultItemKey = (rowIndex: number, columnIndex: number, _data: unknown) => `${rowIndex}:${columnIndex}`;\n\nconst boxStyle: React.CSSProperties = { boxSizing: 'border-box' };\n\n/**\n * Displays a window onto the contents of a virtualized grid starting from `rowOffset`, `columnOffset`.\n * \n * Accepts props defined by {@link DisplayGridProps}. \n * You must pass a single instance of {@link DisplayGridItem} as a child.\n * @group Components\n */\nexport function DisplayGrid(props: DisplayGridProps) {\n  const { width, height, rowCount, rowOffsetMapping, columnCount, columnOffsetMapping, className, innerClassName, \n    rowOffset: rowRenderOffset, columnOffset: colRenderOffset, children,\n    itemData, itemKey = defaultItemKey, outerRender, innerRender, isScrolling } = props;\n\n  const [rowStartIndex, rowStartOffset, rowRenderSize, rowSizes] = getRangeToRender(rowCount, rowOffsetMapping, height, rowRenderOffset);\n  const rowTemplate = getGridTemplate(rowSizes);\n\n  const [colStartIndex, colStartOffset, colRenderSize, colSizes] = getRangeToRender(columnCount, columnOffsetMapping, width, colRenderOffset);\n  const colTemplate = getGridTemplate(colSizes);\n\n  const rowOffset = rowStartOffset - rowRenderOffset;\n  const colOffset = colStartOffset - colRenderOffset;\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do.\n  const ChildVar = children;\n\n  return (\n   <VirtualContainer className={className} render={outerRender}\n        style={{ position: \"relative\", height, width, overflow: \"hidden\", willChange: \"transform\" }}>\n       <VirtualContainer className={innerClassName} render={innerRender}\n        style={{ position: 'absolute',\n          display: 'grid',\n          gridTemplateColumns: colTemplate,\n          gridTemplateRows: rowTemplate,\n          top: rowOffset, \n          left: colOffset, \n          height: rowRenderSize, \n          width: colRenderSize }}>\n        {rowSizes.map((_rowSize, rowIndex) => (\n          <Fragment key={itemKey(rowStartIndex + rowIndex, 0, itemData)}>\n          {colSizes.map((_size, colIndex) => (\n            <ChildVar data={itemData} isScrolling={isScrolling} \n              key={itemKey(rowStartIndex + rowIndex, colStartIndex + colIndex, itemData)} \n              rowIndex={rowStartIndex + rowIndex} columnIndex={colStartIndex + colIndex} style={boxStyle}/>\n          ))}\n          </Fragment>\n        ))}\n      </VirtualContainer>\n    </VirtualContainer>\n  );\n}\n\nexport default DisplayGrid;\n","import { ItemOffsetMapping, ScrollToOption } from './VirtualBase';\nimport { VirtualScrollProxy } from './VirtualScrollProxy';\n\n/**\n * Custom ref handle returned by {@link VirtualGrid} that exposes imperative methods\n * \n * Use `React.useRef<VirtualGridProxy>(null)` to create a ref.\n */\nexport interface VirtualGridProxy {\n  /**\n   * Scrolls the list to the specified row and column in pixels\n   */\n  scrollTo(rowOffset?: number, columnOffset?: number): void;\n\n  /**\n   * Scrolls the list so that the specified item is visible\n   * @param rowIndex - Row of item to scroll to\n   * @param columnIndex - Column of item to scroll to\n   * @param option - Where to {@link ScrollToOption | position} the item within the viewport\n   */\n  scrollToItem(rowIndex?: number, columnIndex?: number, option?: ScrollToOption): void;\n\n  /** Exposes DOM clientWidth property */\n  get clientWidth(): number;\n\n  /** Exposes DOM clientHeight property */\n  get clientHeight(): number;\n\n  /** Current vertical position of scroll bar */\n  get verticalOffset(): number;\n\n  /** Current horizontal position of scroll bar */\n  get horizontalOffset(): number;\n}\n\n/** Range to scroll to in one dimension specified as (offset,size). May be undefined if no need to scroll. */\nexport type ScrollRange = [ offset: number|undefined, size: number|undefined ];\n\n/**\n * Returns the {@link ScrollRange} corresponding to a specified item.\n * \n * Used internally to implement {@link VirtualGridProxy.scrollToItem}. Can be used directly for \n * advanced customization scenarios.\n */\nexport function getRangeToScroll(index: number | undefined, mapping: ItemOffsetMapping): ScrollRange {\n  if (index === undefined)\n    return [undefined, undefined];\n\n  return [mapping.itemOffset(index), mapping.itemSize(index)];\n}\n\n/**\n * Same logic as {@link VirtualGridProxy.scrollToItem} usable with your own {@link VirtualScroll}\n * \n * You're encouraged to put together your own combination of {@link VirtualScroll} and {@link DisplayGrid} for\n * advanced customization scenarios. This function provides `ScrollToItem` functionality for use with your own {@link VirtualScroll}.\n */\nexport function virtualGridScrollToItem(scrollRef: React.RefObject<VirtualScrollProxy>, rowOffsetMapping: ItemOffsetMapping, \n  columnOffsetMapping: ItemOffsetMapping, rowIndex?: number, columnIndex?: number, option?: ScrollToOption) {\n\n  const scroll = scrollRef.current;\n  /* istanbul ignore if */\n  if (!scroll)\n    return;\n\n  const [rowOffset, rowSize] = getRangeToScroll(rowIndex, rowOffsetMapping);\n  const [colOffset, colSize] = getRangeToScroll(columnIndex, columnOffsetMapping);\n\n  scroll.scrollToArea(rowOffset, rowSize, colOffset, colSize, option);\n}\n","import React from \"react\";\nimport { ItemOffsetMapping, VirtualBaseProps, ScrollToOption } from './VirtualBase';\nimport { DisplayGrid, DisplayGridItem } from './DisplayGrid';\nimport { VirtualContainerRender } from './VirtualContainer';\nimport { VirtualScroll } from './VirtualScroll';\nimport { VirtualScrollProxy } from './VirtualScrollProxy';\nimport { virtualGridScrollToItem, VirtualGridProxy } from './VirtualGridProxy';\nimport { AutoSizer } from './AutoSizer';\nimport { ScrollState } from './useVirtualScroll';\n\n/**\n * Props accepted by {@link VirtualGrid}\n */\nexport interface VirtualGridProps extends VirtualBaseProps {\n  /** Component used as a template to render items in the grid. Must implement {@link DisplayGridItem} interface. */\n  children: DisplayGridItem,\n\n  /** Number of rows in the grid */\n  rowCount: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each row in the grid\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  rowOffsetMapping: ItemOffsetMapping,\n\n  /** Number of columns in the grid */\n  columnCount: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each column in the grid\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  columnOffsetMapping: ItemOffsetMapping,\n\n  /**\n   * Function that defines the key to use for each item given row and column index and value of {@link VirtualBaseProps.itemData}.\n   * @defaultValue\n   * ```ts\n   * (rowIndex, columnIndex, _data) => `${rowIndex}:${columnIndex}`\n   * ```\n   */\n  itemKey?: (rowIndex: number, columnIndex: number, data: unknown) => React.Key,\n\n  /**\n   * Callback after a scroll event has been processed and state updated but before rendering\n   * @param rowOffset - Resulting overall row offset. Can be passed to {@link ItemOffsetMapping} to determine first row.\n   * @param columnOffset - Resulting overall column offset. Can be passed to {@link ItemOffsetMapping} to determine first column.\n   * @param newRowScrollState - New {@link ScrollState} for rows that will be used for rendering.\n   * @param newColumnScrollState - New {@link ScrollState} for columns that will be used for rendering.\n   */\n  onScroll?: (rowOffset: number, columnOffset: number, newRowScrollState: ScrollState, newColumnScrollState: ScrollState) => void;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link VirtualGrid} outer container. */\n  outerRender?: VirtualContainerRender;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link DisplayGrid} within {@link VirtualGrid} inner container. */\n  innerRender?: VirtualContainerRender;\n}\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\n/**\n * Virtual Scrolling Grid\n * \n * Accepts props defined by {@link VirtualGridProps}. \n * Refs are forwarded to {@link VirtualGridProxy}. \n * You must pass a single instance of {@link DisplayGridItem} as a child.\n * @group Components\n */\nexport const VirtualGrid = React.forwardRef<VirtualGridProxy, VirtualGridProps>(function VirtualGrid(props, ref) {\n  const { rowCount, rowOffsetMapping, columnCount, columnOffsetMapping, children, \n    innerClassName, innerRender, itemData, itemKey, onScroll: onScrollCallback, ...scrollProps } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalRowSize = rowOffsetMapping.itemOffset(rowCount);\n  const totalColumnSize = columnOffsetMapping.itemOffset(columnCount);\n\n  const scrollRef = React.useRef<VirtualScrollProxy>(null);\n\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(rowOffset?: number, columnOffset?: number): void {\n        const scroll = scrollRef.current;\n        /* istanbul ignore else */\n        if (scroll)\n          scroll.scrollTo(rowOffset, columnOffset);\n      },\n\n      scrollToItem(rowIndex?: number, columnIndex?: number, option?: ScrollToOption): void {\n        virtualGridScrollToItem(scrollRef, rowOffsetMapping, columnOffsetMapping, rowIndex, columnIndex, option);\n      },\n\n      get clientWidth(): number {\n        return scrollRef.current ? scrollRef.current.clientWidth : /* istanbul ignore next */ 0;\n      },\n\n      get clientHeight(): number {\n        return scrollRef.current ? scrollRef.current.clientHeight : /* istanbul ignore next */ 0;\n      },\n\n      get verticalOffset(): number {\n        return scrollRef.current ? scrollRef.current.verticalOffset : /* istanbul ignore next */ 0;\n      },\n\n      get horizontalOffset(): number {\n        return scrollRef.current ? scrollRef.current.horizontalOffset : /* istanbul ignore next */ 0;\n      }\n    }\n  }, [ rowOffsetMapping, columnOffsetMapping ]);\n\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n\n  return (\n    <VirtualScroll\n      ref={scrollRef}\n      {...scrollProps}\n      scrollHeight={totalRowSize}\n      scrollWidth={totalColumnSize}\n      onScroll={(verticalOffset, horizontalOffset, verticalScrollState, horizontalScrollState) => {\n        if (onScrollCallback)\n          onScrollCallback(verticalOffset, horizontalOffset, verticalScrollState, horizontalScrollState);\n      }}>\n      {({ isScrolling, verticalOffset, horizontalOffset }) => (\n        <AutoSizer style={{ height: '100%', width: '100%' }}>\n        {({height,width}) => (\n          <DisplayGrid\n            innerClassName={innerClassName}\n            innerRender={innerRender}\n            rowOffset={verticalOffset}\n            columnOffset={horizontalOffset}\n            height={height}\n            rowCount={rowCount}\n            columnCount={columnCount}\n            itemData={itemData}\n            itemKey={itemKey}\n            isScrolling={isScrolling}\n            rowOffsetMapping={rowOffsetMapping}\n            columnOffsetMapping={columnOffsetMapping}\n            width={width}>\n            {ChildVar}\n        </DisplayGrid>\n      )}\n      </AutoSizer>\n      )}\n    </VirtualScroll>\n  );\n});\n\nexport default VirtualGrid;\n","import { ItemOffsetMapping, ScrollToOption } from './VirtualBase';\nimport { VirtualScrollProxy } from './VirtualScrollProxy';\n\n/**\n * Custom ref handle returned by {@link VirtualList} that exposes imperative methods\n * \n * Use `React.useRef<VirtualListProxy>(null)` to create a ref.\n */\nexport interface VirtualListProxy {\n  /**\n   * Scrolls the list to the specified offset in pixels\n   * @param offset - Offset to scroll to\n   */\n  scrollTo(offset: number): void;\n\n  /**\n   * Scrolls the list so that the specified item is visible\n   * @param index - Index of item to scroll to\n   * @param option - Where to {@link ScrollToOption | position} the item within the viewport\n   */\n  scrollToItem(index: number, option?: ScrollToOption): void;\n\n  /** Current scroll position */\n  get offset(): number;\n}\n\n/**\n * Same logic as {@link VirtualListProxy.scrollToItem} usable with your own {@link VirtualScroll}\n * \n * You're encouraged to put together your own combination of {@link VirtualScroll} and {@link DisplayList} for\n * advanced customization scenarios. This function provides `ScrollToItem` functionality for use with your own {@link VirtualScroll}.\n */\nexport function virtualListScrollToItem(scrollRef: React.RefObject<VirtualScrollProxy>, itemOffsetMapping: ItemOffsetMapping, isVertical: boolean,\n  index: number, option?: ScrollToOption) {\n\n  const scroll = scrollRef.current;\n  /* istanbul ignore if */\n  if (!scroll)\n    return;\n\n  const itemOffset = itemOffsetMapping.itemOffset(index);\n  const itemSize = itemOffsetMapping.itemSize(index);\n\n  if (isVertical)\n    scroll.scrollToArea(itemOffset, itemSize, undefined, undefined, option);\n  else\n    scroll.scrollToArea(undefined, undefined, itemOffset, itemSize, option);\n}","import React from \"react\";\nimport { ItemOffsetMapping, VirtualBaseProps, ScrollToOption, ScrollLayout } from './VirtualBase';\nimport { DisplayList, DisplayListItem } from './DisplayList';\nimport { VirtualContainerRender } from './VirtualContainer';\nimport { VirtualScroll } from './VirtualScroll';\nimport { VirtualScrollProxy } from './VirtualScrollProxy';\nimport { virtualListScrollToItem, VirtualListProxy } from './VirtualListProxy';\nimport { AutoSizer } from './AutoSizer';\nimport { ScrollState } from './useVirtualScroll';\n\n/**\n * Props accepted by {@link VirtualList}\n */\nexport interface VirtualListProps extends VirtualBaseProps {\n  /** Component used as a template to render items in the list. Must implement {@link DisplayListItem} interface. */\n  children: DisplayListItem,\n\n  /** Number of items in the list */\n  itemCount: number,\n\n  /** \n   * Implementation of {@link ItemOffsetMapping} interface that defines size and offset to each item in the list\n   * \n   * Use {@link useFixedSizeItemOffsetMapping} or {@link useVariableSizeItemOffsetMapping} to create implementations\n   * for common cases.\n   */\n  itemOffsetMapping: ItemOffsetMapping,\n\n  /**\n   * Function that defines the key to use for each item given item index and value of {@link VirtualBaseProps.itemData}.\n   * @defaultValue `(index, _data) => index`\n   */\n  itemKey?: (index: number, data: unknown) => React.Key,\n\n  /**\n   * Choice of 'vertical' or 'horizontal' layouts\n   * @defaultValue 'vertical'\n   */\n  layout?: ScrollLayout,\n\n  /**\n   * Callback after a scroll event has been processed and state updated but before rendering\n   * @param offset - Resulting overall offset. Can be passed to {@link ItemOffsetMapping} to determine top item.\n   * @param newScrollState - New {@link ScrollState} that will be used for rendering.\n   */\n  onScroll?: (offset: number, newScrollState: ScrollState) => void;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link VirtualList} outer container. */\n  outerRender?: VirtualContainerRender;\n\n  /** Render prop implementing {@link VirtualContainerRender}. Used to customize {@link DisplayList} within {@link VirtualList} inner container. */\n  innerRender?: VirtualContainerRender;\n}\n\n\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\n/**\n * Virtual Scrolling List\n * \n * Accepts props defined by {@link VirtualListProps}. \n * Refs are forwarded to {@link VirtualListProxy}. \n * You must pass a single instance of {@link DisplayListItem} as a child.\n * @group Components\n */\nexport const VirtualList = React.forwardRef<VirtualListProxy, VirtualListProps>(function VirtualList(props, ref) {\n  const { itemCount, itemOffsetMapping, children, layout = 'vertical', onScroll: onScrollCallback,\n    innerClassName, innerRender, itemData, itemKey, ...scrollProps } = props;\n\n  // Total size is same as offset to item one off the end\n  const renderSize = itemOffsetMapping.itemOffset(itemCount);\n\n  const scrollRef = React.useRef<VirtualScrollProxy>(null);\n  const isVertical = layout === 'vertical';\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(offset: number): void {\n        const scroll = scrollRef.current;\n        /* istanbul ignore if */\n        if (!scroll)\n          return;\n\n        if (isVertical)\n          scroll.scrollTo(offset, undefined);\n        else\n          scroll.scrollTo(undefined, offset);\n      },\n\n      scrollToItem(index: number, option?: ScrollToOption): void {\n        virtualListScrollToItem(scrollRef, itemOffsetMapping, isVertical, index, option);\n      },\n\n      get offset(): number {\n        const scroll = scrollRef.current;\n        /* istanbul ignore if */\n        if (!scroll)\n          return 0;\n\n        return isVertical ? scroll.verticalOffset : scroll.horizontalOffset;\n      }\n    }\n  }, [ itemOffsetMapping, isVertical ]);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do.\n  const ChildVar = children;\n\n  return (\n    <VirtualScroll\n      ref={scrollRef}\n      {...scrollProps}\n      scrollHeight={isVertical ? renderSize : undefined}\n      scrollWidth={isVertical ? undefined : renderSize}\n      onScroll={(verticalOffset, horizontalOffset, verticalScrollState, horizontalScrollState) => {\n        const newOffset = isVertical ? verticalOffset : horizontalOffset;\n        if (onScrollCallback)\n          onScrollCallback(newOffset, isVertical ? verticalScrollState : horizontalScrollState);\n      }}>\n      {({ isScrolling, verticalOffset, horizontalOffset }) => (\n        <AutoSizer style={{ height: '100%', width: '100%' }}>\n        {({height,width}) => (\n          <DisplayList\n            innerClassName={innerClassName}\n            innerRender={innerRender}\n            layout={layout}\n            offset={isVertical ? verticalOffset : horizontalOffset}\n            height={height}\n            itemCount={itemCount}\n            itemData={itemData}\n            itemKey={itemKey}\n            isScrolling={isScrolling}\n            itemOffsetMapping={itemOffsetMapping}\n            width={width}>\n            {ChildVar}\n        </DisplayList>\n      )}\n      </AutoSizer>\n      )}\n    </VirtualScroll>\n  );\n});\n\nexport default VirtualList;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass FixedSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (itemSize: number) {\n    this.fixedItemSize = itemSize;\n  }\n\n  itemSize(_itemIndex: number): number {\n    return this.fixedItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    return itemIndex * this.fixedItemSize;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    const itemIndex = Math.floor(offset / this.fixedItemSize);\n    const startOffset = itemIndex * this.fixedItemSize;\n\n    return [itemIndex, startOffset];\n  }\n\n  fixedItemSize: number;\n}\n\n/**\n * Returns an instance of {@link ItemOffsetMapping} suitable for use when all items have a fixed size.\n * \n * @param itemSize - Size to use for all items\n */\nexport function useFixedSizeItemOffsetMapping(itemSize: number): ItemOffsetMapping {\n  return new FixedSizeItemOffsetMapping(itemSize);\n}\n\nexport default useFixedSizeItemOffsetMapping;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass VariableSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (defaultItemSize: number, sizes: number[]) {\n    this.defaultItemSize = defaultItemSize;\n    this.sizes = sizes;\n  }\n\n  itemSize(itemIndex: number): number {\n    return (itemIndex < this.sizes.length) ? this.sizes[itemIndex] : this.defaultItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    let offset = 0;\n    let length = this.sizes.length;\n    if (itemIndex > length) {\n      const numDefaultSize = itemIndex - length;\n      offset = numDefaultSize * this.defaultItemSize;\n    } else {\n      length = itemIndex;\n    }\n    \n    for (let i = 0; i < length; i ++)\n    {\n      offset += this.sizes[i];\n    }\n\n    return offset;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    let startOffset = 0;\n    const length = this.sizes.length;\n    for (let i = 0; i < length; i ++) {\n      const size = this.sizes[i];\n      if (startOffset + size > offset) {\n        return [i, startOffset];\n      }\n      startOffset += size;\n    }\n\n    const itemIndex = Math.floor((offset - startOffset) / this.defaultItemSize);\n    startOffset += itemIndex * this.defaultItemSize;\n\n    return [itemIndex+length, startOffset];\n  }\n\n  defaultItemSize: number;\n  sizes: number[];\n}\n\n/**\n * Returns an instance of {@link ItemOffsetMapping} suitable for use when initial items have variable sizes.\n * \n * @param defaultItemSize - Size to use for all other items\n * @param sizes - Array of sizes to use for the initial items, one size per item\n */\nexport function useVariableSizeItemOffsetMapping(defaultItemSize: number, sizes?: number[]): ItemOffsetMapping {\n  return new VariableSizeItemOffsetMapping(defaultItemSize, sizes || []);\n}\n\nexport default useVariableSizeItemOffsetMapping;","import type { ItemOffsetMapping } from \"@candidstartup/react-virtual-scroll\";\nexport type { ItemOffsetMapping } from \"@candidstartup/react-virtual-scroll\";\nimport { useFixedSizeItemOffsetMapping } from \"@candidstartup/react-virtual-scroll\";\n\nexport type CellErrorValue = '#NULL!' | \n  '#DIV/0!' |\n  '#VALUE!' |\n  '#REF!' |\n  '#NAME?' |\n  '#NUM!' |\n  '#N/A' |\n  '#GETTING_DATA' |\n  '#SPILL!' |\n  '#UNKNOWN!' |\n  '#FIELD!' |\n  '#CALC!';\n\nexport interface CellError {\n  type: 'CellError',\n  value: CellErrorValue;\n};\n\nexport type CellValue = string | number | boolean | null | undefined | CellError;\n\nexport interface SpreadsheetData<Snapshot> {\n  subscribe(onDataChange: () => void): () => void,\n  getSnapshot(): Snapshot,\n\n  getRowCount(snapshot: Snapshot): number,\n  getRowItemOffsetMapping(snapshot: Snapshot): ItemOffsetMapping,\n  getColumnCount(snapshot: Snapshot): number,\n  getColumnItemOffsetMapping(snapshot: Snapshot): ItemOffsetMapping,\n  getCellValue(snapshot: Snapshot, row: number, column: number): CellValue;\n  getCellFormat(snapshot: Snapshot, row: number, column: number): string | undefined;\n  setCellValueAndFormat(row: number, column: number, value: CellValue, format: string | undefined): boolean;\n}\n\nconst rowItemOffsetMapping = useFixedSizeItemOffsetMapping(30);\nconst columnItemOffsetMapping = useFixedSizeItemOffsetMapping(100);\n\nexport class EmptySpreadsheetData implements SpreadsheetData<number> {\n  subscribe(_onDataChange: () => void) { return () => {}; }\n  getSnapshot() { return 0; }\n  \n  getRowCount(_snapshot: number) { return 0; }\n  getRowItemOffsetMapping(_snapshot: number): ItemOffsetMapping { return rowItemOffsetMapping; }\n  getColumnCount(_snapshot: number) { return 0; }\n  getColumnItemOffsetMapping(_snapshot: number): ItemOffsetMapping { return columnItemOffsetMapping; }\n  getCellValue(_snapshot: number, _row: number, _column: number): CellValue { return null; }\n  getCellFormat(_snapshot: number, _row: number, _column: number): string|undefined { return undefined; }\n  setCellValueAndFormat(_row: number, _column: number, _value: CellValue, _format: string | undefined): boolean { return false; }\n}\n\n","/**  Classic Spreadsheet reference to Column (e.g \"A\") */\nexport type ColRef = string;\n\n/**  Classic Spreadsheet reference to Cell (e.g. \"A1\"), Row (e.g. \"1\") or Column (e.g \"A\") */\nexport type RowColRef = string;\n\n/** Equivalent to {@link RowColRef} as coordinate pair. \"A1\" has coords [0,0], \"1\" is [0,undefined] and \"A\" is [undefined,0] */\nexport type RowColCoords = [row: number|undefined, col: number|undefined];\n\n/** Converts a {@link ColRef} to the 0-based index of the column */\nexport function colRefToIndex(col: ColRef): number {\n  let n = 0;\n  for (let i = 0; i < col.length; i ++) {\n    n = col.charCodeAt(i) - 64 + n * 26;\n  }\n  return n-1;\n}\n\n/** Converts a 0-based column index to a {@link ColRef} */\nexport function indexToColRef(index: number): ColRef {\n  let ret = \"\";\n  index ++;\n  while (index > 0) {\n    index --;\n    const remainder = index % 26;\n    index = Math.floor(index / 26);\n    ret = String.fromCharCode(65+remainder) + ret;\n  }\n  return ret;\n}\n\n/** Splits a RowColRef into a 0-based row index and a {@link ColRef} */\nexport function splitRowColRef(ref: RowColRef): [row: number|undefined, col: ColRef|undefined] {\n  const re = /^([A-Z]*)(\\d*)$/;\n  const found = ref.match(re);\n  if (!found)\n    return [undefined,undefined];\n\n  const col = found[1];\n  const row = parseInt(found[2]);\n  return [(row>0) ? row-1 : undefined, col ? col : undefined];\n}\n\n/**  Converts a {@link RowColRef} to {@link RowColCoords} */\nexport function rowColRefToCoords(ref: RowColRef): RowColCoords {\n  const [row,col] = splitRowColRef(ref);\n  return [row, col ? colRefToIndex(col) : undefined];\n}\n\n/**  Converts {@link RowColCoords} to a {@link RowColRef} */\nexport function rowColCoordsToRef(row: number|undefined, col: number|undefined): RowColRef {\n  if (row !== undefined) {\n    if (col !== undefined) {\n      return indexToColRef(col) + (row+1);\n    } else {\n      return (row+1).toString();\n    }\n  } else {\n    if (col !== undefined) {\n      return indexToColRef(col);\n    } else {\n      return \"\";\n    }\n  }\n}","/**\n * Theme that defines class names for all DOM elements within {@link VirtualSpreadsheet}. Provide an appropriate\n * theme to use VirtualSpreadsheet with whatever CSS management system you prefer.\n */\nexport interface VirtualSpreadsheetTheme {\n  VirtualSpreadsheet: string,\n  VirtualSpreadsheet_InputBar: string,\n  VirtualSpreadsheet_Name: string,\n  VirtualSpreadsheet_Fx: string,\n  VirtualSpreadsheet_Formula: string,\n  VirtualSpreadsheet_Grid: string,\n  VirtualSpreadsheet_CornerHeader: string,\n  VirtualSpreadsheet_ColumnHeader: string,\n  VirtualSpreadsheet_Column: string,\n  VirtualSpreadsheet_Column__Selected: string,\n  VirtualSpreadsheet_Column__CellSelected: string,\n  VirtualSpreadsheet_RowHeader: string,\n  VirtualSpreadsheet_Row: string,\n  VirtualSpreadsheet_Row__Selected: string,\n  VirtualSpreadsheet_Row__CellSelected: string,\n  VirtualSpreadsheet_Cell: string,\n  VirtualSpreadsheet_Cell__Type_string: string,\n  VirtualSpreadsheet_Cell__Type_number: string,\n  VirtualSpreadsheet_Cell__Type_boolean: string,\n  VirtualSpreadsheet_Cell__Type_null: string,\n  VirtualSpreadsheet_Cell__Type_undefined: string,\n  VirtualSpreadsheet_Cell__Type_CellError: string,\n  VirtualSpreadsheet_Cell__Focus: string,\n  VirtualSpreadsheet_Cell__RowSelected: string,\n  VirtualSpreadsheet_Cell__ColumnSelected: string,\n}\n\nexport const VirtualSpreadsheetDefaultTheme: VirtualSpreadsheetTheme = {\n  VirtualSpreadsheet: \"VirtualSpreadsheet\",\n  VirtualSpreadsheet_InputBar: \"VirtualSpreadsheet_InputBar\",\n  VirtualSpreadsheet_Name: \"VirtualSpreadsheet_Name\",\n  VirtualSpreadsheet_Fx: \"VirtualSpreadsheet_Fx\",\n  VirtualSpreadsheet_Formula: \"VirtualSpreadsheet_Formula\",\n  VirtualSpreadsheet_Grid: \"VirtualSpreadsheet_Grid\",\n  VirtualSpreadsheet_CornerHeader: \"VirtualSpreadsheet_CornerHeader\",\n  VirtualSpreadsheet_ColumnHeader: \"VirtualSpreadsheet_ColumnHeader\",\n  VirtualSpreadsheet_Column: \"VirtualSpreadsheet_Column\",\n  VirtualSpreadsheet_Column__Selected: \"VirtualSpreadsheet_Column__Selected\",\n  VirtualSpreadsheet_Column__CellSelected: \"VirtualSpreadsheet_Column__CellSelected\",\n  VirtualSpreadsheet_RowHeader: \"VirtualSpreadsheet_RowHeader\",\n  VirtualSpreadsheet_Row: \"VirtualSpreadsheet_Row\",\n  VirtualSpreadsheet_Row__Selected: \"VirtualSpreadsheet_Row__Selected\",\n  VirtualSpreadsheet_Row__CellSelected: \"VirtualSpreadsheet_Row__CellSelected\",\n  VirtualSpreadsheet_Cell: \"VirtualSpreadsheet_Cell\",\n  VirtualSpreadsheet_Cell__Type_string: \"VirtualSpreadsheet_Cell__Type_string\",\n  VirtualSpreadsheet_Cell__Type_number: \"VirtualSpreadsheet_Cell__Type_number\",\n  VirtualSpreadsheet_Cell__Type_boolean: \"VirtualSpreadsheet_Cell__Type_boolean\",\n  VirtualSpreadsheet_Cell__Type_null: \"VirtualSpreadsheet_Cell__Type_null\",\n  VirtualSpreadsheet_Cell__Type_undefined: \"VirtualSpreadsheet_Cell__Type_undefined\",\n  VirtualSpreadsheet_Cell__Type_CellError: \"VirtualSpreadsheet_Cell__Type_CellError\",\n  VirtualSpreadsheet_Cell__Focus: \"VirtualSpreadsheet_Cell__Focus\",\n  VirtualSpreadsheet_Cell__RowSelected: \"VirtualSpreadsheet_Cell__RowSelected\",\n  VirtualSpreadsheet_Cell__ColumnSelected: \"VirtualSpreadsheet_Cell__ColumnSelected\"\n}\n","import React from 'react';\nimport { DisplayList, DisplayGrid, AutoSizer, VirtualContainerRender, VirtualScroll, VirtualScrollProxy,\n  getRangeToScroll, getOffsetToScrollRange } from '@candidstartup/react-virtual-scroll';\nimport type { VirtualSpreadsheetTheme } from './VirtualSpreadsheetTheme';\nimport { indexToColRef, RowColCoords, rowColRefToCoords, rowColCoordsToRef } from './RowColRef'\nimport type { SpreadsheetData, CellValue } from './SpreadsheetData'\nimport * as numfmt from 'numfmt'\n\nexport interface ReactSpreadsheetData<Snapshot> extends SpreadsheetData<Snapshot> {\n  getServerSnapshot?: () => Snapshot\n}\n\n/**\n * Props for {@link VirtualSpreadsheet}\n */\nexport interface VirtualSpreadsheetProps<Snapshot> {\n  /** The `className` applied to the spreadsheet as a whole */\n  className?: string,\n\n  theme?: VirtualSpreadsheetTheme | Record<string, string>,\n\n  /** Component height */\n  height: number,\n\n   /** Component width */\n  width: number,\n\n  /** Data to display and edit */\n  data: ReactSpreadsheetData<Snapshot>,\n\n  /** Minimum number of rows in the spreadsheet \n   * @defaultValue 100\n  */\n  minRowCount?: number,\n\n  /** Maximum number of rows in the spreadsheet \n   * @defaultValue 1000000000000\n  */\n  maxRowCount?: number,\n\n  /** Minimum number of columns in the grid \n   * @defaultValue 26\n  */\n  minColumnCount?: number,\n\n  /** Maximum umber of columns in the grid \n   * @defaultValue 1000000000000\n  */\n  maxColumnCount?: number,\n\n  /** \n   * Maximum size for CSS element beyond which layout breaks. You should never normally need to change this. \n   * The default value is compatible with all major browsers.\n   * \n   * @defaultValue 6000000\n   * */\n  maxCssSize?: number,\n\n  /**\n   * The minimum number of virtual pages to use when inner container would otherwise be more than {@link VirtualSpreadsheetProps.maxCssSize} big.\n   * You should never normally need to change this.\n   * \n   * @defaultValue 100\n   */\n  minNumPages?: number\n}\n\nfunction join(...v: (string|undefined)[]) {\n  let s: string|undefined = undefined;\n  v.forEach(a => {\n    if (s && a)\n      s = s + ' ' + a;\n    else if (a)\n      s = a;\n  });\n  return s;\n}\n\nfunction ifdef(b: boolean|null, s: string|undefined) { return (b) ? s : undefined }\n\n// Options for numfmt that match Google Sheets and ECMA-376 behavior. This is compatible with supported dates in Excel apart from Jan/Feb 1900. \n// This is due to Excel's backwards compatibility support for the Lotus 1-2-3 leap year bug that incorrectly thinks 1900 is a leap year.\nconst numfmtOptions = {\n  leap1900: false,\n  dateSpanLarge: true\n}\n\nfunction formatContent(value: CellValue, format: string | undefined): string {\n  if (value === null ||  value === undefined)\n    return \"\";\n\n  if (typeof value === 'object')\n      return value.value;\n\n  if (typeof value === 'string' && value[0] == '\\'') {\n    // Leading apostrophe means display rest of string as is\n    return value.substring(1);\n  }\n\n  if (format === undefined)\n    format = \"\";\n\n  return numfmt.format(format, value, numfmtOptions);\n}\n\nfunction classForType(value: CellValue) {\n  if (value === null)\n    return 'VirtualSpreadsheet_Cell__Type_null';\n  if (value === undefined)\n    return 'VirtualSpreadsheet_Cell__Type_undefined';\n\n  const type = typeof value;\n  if (type === 'object')\n    return 'VirtualSpreadsheet_Cell__Type_CellError';\n\n  return 'VirtualSpreadsheet_Cell__Type_' + type;\n}\n\ntype HeaderItemRender = (index: number, style: React.CSSProperties) => JSX.Element;\nfunction HeaderItem({ index, data, style }: { index: number, data:unknown, style: React.CSSProperties }) {\n  const itemRender = data as HeaderItemRender;\n  return itemRender(index, style);\n}\n\ntype CellRender = (rowIndex: number, columnIndex: number, style: React.CSSProperties) => JSX.Element;\nfunction Cell({ rowIndex, columnIndex, data, style }: { rowIndex: number, columnIndex: number, data: unknown, style: React.CSSProperties }) {\n  const cellRender = data as CellRender;\n  return cellRender(rowIndex, columnIndex, style);\n}\n\nexport function VirtualSpreadsheet<Snapshot>(props: VirtualSpreadsheetProps<Snapshot>) {\n  const { width, height, theme, data, minRowCount=100, minColumnCount=26, maxRowCount=1000000000000, maxColumnCount=1000000000000 } = props;\n  const scrollRef = React.useRef<VirtualScrollProxy>(null);\n  const focusSinkRef = React.useRef<HTMLInputElement>(null);\n\n  // Originally passed data.subscribe.bind(data) to useCallback. It works but React hooks lint fails because it can only validate\n  // dependencies for an inline function.\n  const subscribeFn = React.useCallback((cb: () => void) => data.subscribe(cb), [data]); \n  const snapshot = React.useSyncExternalStore<Snapshot>(subscribeFn, data.getSnapshot.bind(data), data.getServerSnapshot?.bind(data));\n\n  const [name, setName] = React.useState(\"\");\n  const [formula, setFormula] = React.useState(\"\");\n  const [cellValue, setCellValue] = React.useState(\"\");\n  const [editMode, setEditMode] = React.useState(false);\n  const [hwmRowIndex, setHwmRowIndex] = React.useState(0);\n  const [hwmColumnIndex, setHwmColumnIndex] = React.useState(0);\n  const [selection, setSelection] = React.useState<RowColCoords>([undefined,undefined]);\n  const [focusCell, setFocusCell] = React.useState<[number,number]|null>(null);\n  const [[gridRowOffset, gridColumnOffset], setGridScrollState] = React.useState<[number,number]>([0, 0]);\n\n  const dataRowCount = data.getRowCount(snapshot);\n  const rowCount = Math.max(minRowCount, dataRowCount, hwmRowIndex+1, focusCell ? focusCell[0]+1 : 0);\n  const rowMapping = data.getRowItemOffsetMapping(snapshot);\n  const rowOffset = rowMapping.itemOffset(rowCount);\n  const dataColumnCount = data.getColumnCount(snapshot);\n  const columnCount = Math.max(minColumnCount, dataColumnCount, hwmColumnIndex+1, focusCell ? focusCell[1]+1 : 0);\n  const columnMapping = data.getColumnItemOffsetMapping(snapshot);\n  const columnOffset = columnMapping.itemOffset(columnCount);\n\n  React.useEffect(() => {\n    scrollRef.current?.scrollTo(gridRowOffset, gridColumnOffset);\n  }, [gridRowOffset, gridColumnOffset])\n\n  React.useEffect(() => {\n    focusSinkRef.current?.focus({preventScroll: true})\n  }, [focusCell])\n\n  function onScroll(rowOffsetValue: number, columnOffsetValue: number) {\n    if (rowOffsetValue == gridRowOffset && columnOffsetValue == gridColumnOffset)\n      return;\n\n    if (rowOffsetValue == 0)\n      setHwmRowIndex(0);\n    else if (scrollRef.current && (rowOffsetValue + scrollRef.current.clientHeight == rowOffset)) {\n      // Infinite scrolling if we've reached the end\n      if (hwmRowIndex < rowCount && rowCount < maxRowCount)\n        setHwmRowIndex(rowCount);\n    }\n\n    if (columnOffsetValue == 0)\n      setHwmColumnIndex(0);\n    else if (scrollRef.current && (columnOffsetValue + scrollRef.current.clientWidth == columnOffset)) {\n      // Infinite scrolling if we've reached the end\n      if (hwmColumnIndex < columnCount && columnCount < maxColumnCount)\n        setHwmColumnIndex(columnCount);\n    }\n\n    setGridScrollState([rowOffsetValue, columnOffsetValue]);\n  }\n\n  function updateFormula(rowIndex: number, colIndex: number, editMode: boolean) {\n    if (rowIndex < dataRowCount && colIndex < dataColumnCount) {\n      const dataValue = data.getCellValue(snapshot, rowIndex, colIndex);\n      const format = data.getCellFormat(snapshot, rowIndex, colIndex);\n      const value = formatContent(dataValue, format);\n      setFormula(value);\n      setCellValue(editMode ? value : \"\");\n    } else {\n      setFormula(\"\");\n      setCellValue(\"\");\n    }\n  }\n\n  function updateFocus(rowIndex: number, colIndex: number) {\n    if (!focusCell || rowIndex != focusCell[0] || colIndex != focusCell[1]) {\n      // Reset formula and edit mode only if the focus cell is changing\n      updateFormula(rowIndex, colIndex, false);\n      setEditMode(false);\n    }\n\n    // We use change of focusCell state to trigger effect that gives focus to the focus sink\n    // Make sure we always change state, even if focus cell hasn't changed. Any click in grid\n    // removes focus from focus sink. Need to make sure it's always given back, even if user\n    // clicked on focus cell again. \n    setFocusCell([rowIndex, colIndex]);\n  }\n\n  function updateSelection(row: number|undefined, col: number|undefined) {\n    if (row === undefined && col === undefined) {\n      // Clear out and bail if nothing selected\n      setFocusCell(null);\n      setFormula(\"\");\n      setCellValue(\"\");\n      setEditMode(false);\n      return;\n    }\n\n    if (row !== selection[0] || col !== selection[1]) {\n      setSelection([row,col]);\n      setName(rowColCoordsToRef(row,col));\n    }\n\n    const rowIndex = row ? row : 0;\n    const colIndex = col ? col : 0;\n    updateFocus(rowIndex, colIndex);\n  }\n\n  function ensureVisible(row: number|undefined, col: number|undefined) {\n    const scroll = scrollRef.current;\n    if (!scroll)\n      return;\n\n    // Implements same logic as VirtualScrollProxy.scrollToArea so that we can directly update our grid scroll state.\n    // React 18+ gives scroll events a lower priority than discrete events like key and mouse clicks. If we use\n    // scrollToArea + OnScroll callback we can end up with other state changes being rendered immediately with the\n    // scroll related changes being rendered a frame later. \n    // Scroll bar position is synchronized with state in an effect post render.\n    const rowRange = getRangeToScroll(row, rowMapping);\n    const colRange = getRangeToScroll(col, columnMapping);\n\n    const newRowOffset = getOffsetToScrollRange(...rowRange, scroll.clientHeight, gridRowOffset, 'visible');\n    const newColOffset = getOffsetToScrollRange(...colRange, scroll.clientWidth, gridColumnOffset, 'visible');\n    if (newRowOffset !== undefined || newColOffset !== undefined) {\n      setGridScrollState([(newRowOffset === undefined) ? gridRowOffset : newRowOffset, (newColOffset === undefined) ? gridColumnOffset : newColOffset]);\n    }\n  }\n\n  // Is cell in selected row or column?\n  function isInSelection(row: number|undefined, col: number|undefined): boolean {\n    if (row === undefined || col === undefined)\n      return false;\n\n    return (selection[0] === undefined && col === selection[1]) ||\n      (selection[1] === undefined && row === selection[0]);\n  }\n\n  // Expands grid as needed for target cell\n  function selectItem(row: number|undefined, col: number|undefined, keepSelection?: boolean) {\n    if (row !== undefined) {\n      if (row < 0)\n        return;\n      if (row >= maxRowCount)\n        row = maxRowCount - 1;\n      if (row > hwmRowIndex) {\n        setHwmRowIndex(row);\n      } else if (row == 0)\n        setHwmRowIndex(0);\n    }\n\n    if (col !== undefined) {\n      if (col < 0)\n        return;\n      if (col >= maxColumnCount)\n        col = maxColumnCount - 1;\n      if (col > hwmColumnIndex) {\n        setHwmColumnIndex(col);\n      } else if (col == 0)\n        setHwmColumnIndex(0);\n    }\n\n    // If desired and possible move focus within existing selection rather than changing selection\n    if (keepSelection && isInSelection(row,col)) {\n      const rowIndex = row ? row : 0;\n      const colIndex = col ? col : 0;\n      updateFocus(rowIndex, colIndex);\n    } else {\n      updateSelection(row,col);\n    }\n    ensureVisible(row,col);\n  }\n\n  // Move on to next cell. \n  // Moves within selected row or column. If none moves vertically if isVertical otherwise horizontally. \n  // Move backwards (left/dup) if isBackwards, otherwise forwards\n  function nextCell(row: number, col: number, isVertical: boolean, isBackwards: boolean) {\n    if (selection[0] === undefined && selection[1] === undefined)\n      return;\n\n    const offset = isBackwards ? -1 : 1;\n\n    if (selection[0] === undefined) {\n      // Column selected - move vertically within existing selection\n      selectItem(row+offset, col, true);\n    } else if (selection[1] === undefined) {\n      // Row selected - move horizontally within existing selection\n      selectItem(row, col+offset, true);\n    } else {\n      // Cell selected\n      if (isVertical)\n        selectItem(row+offset,col);\n      else\n        selectItem(row,col+offset);\n    }\n  }\n\n  function onNameKeyUp(event: React.KeyboardEvent<HTMLInputElement>) {\n    if (event.key !== \"Enter\")\n      return;\n\n    const [row, col] = rowColRefToCoords(name);\n    selectItem(row,col);\n  }\n\n  function CommitFormulaChange(rowIndex: number, colIndex: number) {\n    let value: CellValue = undefined;\n    let format: string | undefined = undefined;\n    const parseData =  numfmt.parseValue(formula);\n    if (parseData) {\n      // number or boolean\n      value = parseData.v;\n      format = parseData.z;\n    } else {\n      // string\n      value = formula;\n    }\n\n    data.setCellValueAndFormat(rowIndex, colIndex, value, format);\n  }\n\n  // Used by both formula and focus sink input fields\n  function onEditValueKeyDown(event: React.KeyboardEvent<HTMLInputElement>) {\n    if (!focusCell)\n      return;\n\n    const row = focusCell[0];\n    const col = focusCell[1];\n\n    if (editMode) {\n      switch (event.key) {\n        case \"Escape\": { \n          updateFormula(row, col, false); \n          setEditMode(false); \n          setFocusCell([row, col]); \n        } \n        break;\n\n        case \"Enter\": { \n          CommitFormulaChange(row, col); \n          updateFormula(row, col, false); \n          setEditMode(false);\n          nextCell(row,col,true,event.shiftKey);\n        } \n        break;\n\n        case \"Tab\": { \n          CommitFormulaChange(row, col); \n          updateFormula(row, col, false); \n          setEditMode(false);\n          nextCell(row,col,false,event.shiftKey);\n          event.preventDefault();\n        } \n        break;\n      }\n    } else {\n      switch (event.key) {\n        case \"ArrowDown\": { selectItem(row+1,col); event.preventDefault(); } break;\n        case \"ArrowUp\": { selectItem(row-1,col); event.preventDefault(); } break;\n        case \"ArrowLeft\": { selectItem(row,col-1); event.preventDefault(); } break;\n        case \"ArrowRight\": { selectItem(row,col+1); event.preventDefault(); } break;\n        case \"Tab\": { nextCell(row,col,false,event.shiftKey); event.preventDefault(); } break;\n        case \"Enter\": { \n          if (isInSelection(row,col)) {\n            nextCell(row,col,true,event.shiftKey);\n          } else {\n            updateFormula(row, col, true); \n            setEditMode(true);\n          }\n        } \n        break;\n      }\n    }\n  }\n\n  function colSelected(index: number) { return (selection[0] == undefined && selection[1] == index) }\n  function colCellSelected(index: number) { \n    return (selection[0] != undefined) && (selection[1] == undefined || selection[1] == index)\n  }\n  function rowSelected(index: number) { return (selection[0] == index && selection[1] == undefined) }\n  function rowCellSelected(index: number) { \n    return (selection[1] != undefined) && (selection[0] == undefined || selection[0] == index)\n  }\n\n  const colHeaderRender: VirtualContainerRender = ({...rest}, ref) => (\n    <div ref={ref}\n    onClick={(event) => {\n      const headerRect = event.currentTarget.getBoundingClientRect();\n      const colOffset = event.clientX - headerRect.left + gridColumnOffset;\n      const [colIndex] = columnMapping.offsetToItem(colOffset);\n      updateSelection(undefined,colIndex);\n    }} \n    {...rest}/>\n  )\n\n  const rowHeaderRender: VirtualContainerRender = ({...rest}, ref) => (\n    <div ref={ref}\n    onClick={(event) => {\n      const headerRect = event.currentTarget.getBoundingClientRect();\n      const rowOffset = event.clientY - headerRect.top + gridRowOffset;\n      const [rowIndex] = rowMapping.offsetToItem(rowOffset);\n      updateSelection(rowIndex, undefined);\n    }} \n    {...rest}/>\n  )\n  \n  const colRender: HeaderItemRender = (index, style ) => (\n    <div className={join(theme?.VirtualSpreadsheet_Column, \n                    ifdef(colSelected(index), theme?.VirtualSpreadsheet_Column__Selected),\n                    ifdef(colCellSelected(index), theme?.VirtualSpreadsheet_Column__CellSelected))} \n         style={style}>\n      { indexToColRef(index) }\n    </div>\n  );\n  \n  const rowRender: HeaderItemRender = (index, style) => (\n    <div className={join(theme?.VirtualSpreadsheet_Row, \n                    ifdef(rowSelected(index), theme?.VirtualSpreadsheet_Row__Selected),\n                    ifdef(rowCellSelected(index), theme?.VirtualSpreadsheet_Row__CellSelected))}\n         style={style}>\n      { index+1 }\n    </div>\n  );\n  \n  const outerGridRender: VirtualContainerRender = ({children, ...rest}, ref) => {\n    let focusSink;\n    if (focusCell) {\n      const row = focusCell[0];\n      const col = focusCell[1];\n\n      // Position focus sink underneath focused cell. If outside viewport clamp position.\n      // Careful - focus cell might be bigger than the viewport!\n      const focusHeight = rowMapping.itemSize(row);\n      let focusTop = rowMapping.itemOffset(row) - gridRowOffset;\n      if (focusTop < -focusHeight)\n        focusTop = -focusHeight;\n      else if (focusTop > height)\n        focusTop = height;\n\n      const focusWidth = columnMapping.itemSize(col);\n      let focusLeft = columnMapping.itemOffset(col) - gridColumnOffset;\n      if (focusLeft < -focusWidth)\n        focusLeft = -focusWidth;\n      else if (focusLeft > width)\n        focusLeft = width;\n\n      // Browser will try and bring focus sink into view in various scenarios like text being typed or user\n      // giving it focus by tabbing between fields. All browsers I tested make a horrible mess of things\n      // due to the sticky positioning. Need to use my own ensureVisible method to clean up.\n      focusSink = <input\n        ref={focusSinkRef}\n        className={join(theme?.VirtualSpreadsheet_Cell, theme?.VirtualSpreadsheet_Cell__Focus)}\n        type={\"text\"}\n        value={cellValue}\n        onChange={(event) => {\n          setCellValue(event.target?.value);\n          setEditMode(true);\n          setFormula(event.target?.value);\n        }}\n        onFocus={() => { ensureVisible(row,col) }}\n        onBeforeInput={() => { ensureVisible(row,col) }}\n        onKeyDown={onEditValueKeyDown}\n        style={{ zIndex: editMode ? 1 : -1, position: \"absolute\", top: focusTop, height: focusHeight, left: focusLeft, width: focusWidth }}\n      />\n    }\n    return <div ref={ref}\n      onClick={(event) => {\n        const gridRect = event.currentTarget.getBoundingClientRect();\n        const colOffset = event.clientX - gridRect.left + gridColumnOffset;\n        const rowOffset = event.clientY - gridRect.top + gridRowOffset;\n        const [rowIndex] = rowMapping.offsetToItem(rowOffset);\n        const [colIndex] = columnMapping.offsetToItem(colOffset);\n        updateSelection(rowIndex,colIndex);\n      }} \n      onDoubleClick={(_event) => {\n        setCellValue(formula);\n        setEditMode(true);\n      }} \n      {...rest}>\n      {children}\n      {focusSink}\n    </div>\n  }\n\n  const cellRender: CellRender = (rowIndex, columnIndex, style) => {\n    let dataValue: CellValue = undefined;\n    let value:string = \"\";\n    if (rowIndex < dataRowCount && columnIndex < dataColumnCount) {\n      dataValue = data.getCellValue(snapshot, rowIndex, columnIndex);\n      const format = data.getCellFormat(snapshot, rowIndex, columnIndex);\n      value = formatContent(dataValue, format);\n    }\n\n    const focused = focusCell && rowIndex == focusCell[0] && columnIndex == focusCell[1];\n    const classNames = join(theme?.VirtualSpreadsheet_Cell,\n      ifdef(rowSelected(rowIndex), theme?.VirtualSpreadsheet_Cell__RowSelected),\n      ifdef(colSelected(columnIndex), theme?.VirtualSpreadsheet_Cell__ColumnSelected),\n      classForType(dataValue),\n      ifdef(focused, theme?.VirtualSpreadsheet_Cell__Focus));\n\n    return <div className={classNames} style={style}>\n      { value }\n    </div>\n  };\n\n  return (\n    <div className={join(props.className, theme?.VirtualSpreadsheet)} style={{display: \"grid\", gridTemplateColumns: \"100px 1fr\", gridTemplateRows: \"30px 50px 1fr\"}}>\n      <div className={theme?.VirtualSpreadsheet_InputBar} style={{display: \"flex\", gridColumnStart: 1, gridColumnEnd: 3}}>\n        <input className={theme?.VirtualSpreadsheet_Name}\n          type={\"text\"}\n          name={\"name\"}\n          title={\"Name\"}\n          value={name}\n          size={20}\n          onChange={(event) => {\n            setName(event.target?.value);\n          }}\n          onKeyUp={onNameKeyUp}\n        />\n        <label className={theme?.VirtualSpreadsheet_Fx}>fx</label>\n        <input className={theme?.VirtualSpreadsheet_Formula}\n          style={{flexGrow: 1}}\n          type={\"text\"}\n          name={\"formula\"}\n          title={\"Formula\"}\n          value={formula}\n          onChange={(event) => {\n            setFormula(event.target?.value);\n            setEditMode(true);\n            if (focusCell)\n              setCellValue(event.target?.value);\n          }}\n          onFocus={() => {\n              if (focusCell) {\n                setCellValue(formula);\n                setEditMode(true);\n              }\n          }}\n          onKeyDown={onEditValueKeyDown}\n        />\n      </div>\n\n      <div className={theme?.VirtualSpreadsheet_CornerHeader}></div>\n\n      <DisplayList\n        offset={gridColumnOffset}\n        className={theme?.VirtualSpreadsheet_ColumnHeader}\n        itemData={colRender}\n        outerRender={colHeaderRender}\n        height={50}\n        itemCount={columnCount}\n        itemOffsetMapping={columnMapping}\n        layout={'horizontal'}\n        width={props.width}>\n        {HeaderItem}\n      </DisplayList>\n\n      <DisplayList\n        offset={gridRowOffset}\n        className={theme?.VirtualSpreadsheet_RowHeader}\n        itemData={rowRender}\n        outerRender={rowHeaderRender}\n        height={props.height}\n        itemCount={rowCount}\n        itemOffsetMapping={rowMapping}\n        width={100}>\n        {HeaderItem}\n      </DisplayList>\n\n      <VirtualScroll\n        className={theme?.VirtualSpreadsheet_Grid}\n        ref={scrollRef}\n        onScroll={onScroll}\n        height={props.height}\n        width={props.width}\n        scrollHeight={rowOffset}\n        scrollWidth={columnOffset}\n        useOffsets={false}\n        maxCssSize={props.maxCssSize}\n        minNumPages={props.minNumPages}>\n        {(_) => (\n          <AutoSizer style={{ height: '100%', width: '100%' }}>\n          {({height,width}) => (\n            <DisplayGrid\n              rowOffset={gridRowOffset}\n              columnOffset={gridColumnOffset}\n              height={height}\n              width={width}\n              itemData={cellRender}\n              outerRender={outerGridRender}\n              rowCount={rowCount}\n              rowOffsetMapping={rowMapping}\n              columnCount={columnCount}\n              columnOffsetMapping={columnMapping}>\n              {Cell}\n            </DisplayGrid>\n          )}\n          </AutoSizer>\n        )}\n      </VirtualScroll>\n    </div>\n  )\n}\n","import { EmptySpreadsheetData, CellValue } from '@candidstartup/react-spreadsheet';\nimport { ItemOffsetMapping, useVariableSizeItemOffsetMapping } from '@candidstartup/react-virtual-scroll';\nimport { dateToSerial } from 'numfmt'\n\nconst headerRow = [ \"Date\", \"Time\", \"Item\", \"Price\", \"Quantity\", \"Cost\", \"Tax Rate\", \"Tax\", \"Subtotal\", \"Transaction Fee\", \"Total\", \"Running Total\"];\nconst totalHeaderRow = [ \"First\", \"Last\", \"Count\", \"Average\", \"Max\", \"Total\", \"Min\", \"Total\", \"Total\", \"Total\", \"Total\", \"Running Total\"]\nconst columnMapping = useVariableSizeItemOffsetMapping(100, [160]);\nconst rowMapping = useVariableSizeItemOffsetMapping(30, [50]);\n\nexport class BoringData extends EmptySpreadsheetData {\n  constructor() { \n    super();\n    this.count = 1000000;\n    const now = new Date();\n    const serialNow = dateToSerial(now) || 0;\n    this.base = serialNow - this.count / (24*60);\n  }\n\n  subscribe(onDataChange: () => void) {\n    const intervalId = setInterval(() => { \n      this.count ++;\n      onDataChange();\n    }, 60000)\n    return () => { clearInterval(intervalId) }\n  }\n\n  getSnapshot() { return this.count; }\n  \n  getRowCount(snapshot: number) { return snapshot+4; }\n  getRowItemOffsetMapping(_snapshot: number): ItemOffsetMapping { return rowMapping; }\n  getColumnCount(_snapshot: number) { return 12; }\n  getColumnItemOffsetMapping(_snapshot: number): ItemOffsetMapping { return columnMapping; }\n\n  dateTime(row: number) { return this.base + row / (24*60); }\n\n  totalRow(num: number, column: number): CellValue {\n    switch (column) { \n      case 0: return this.dateTime(1);\n      case 1: return this.dateTime(num);\n      case 2: return num;\n      case 3: return 0.01;\n      case 4: return 80;\n      case 5: return 0.80 * num;\n      case 6: return 0.15;\n      case 7: return 0.12 * num;\n      case 8: return 0.92 * num;\n      case 9: return 0.08 * num;\n      case 10: return num;\n      case 11: return num;\n    }\n  }\n\n  getCellValue(snapshot: number, row: number, column: number): CellValue {\n    if (row == 0)\n      return headerRow[column];\n\n    if (row == snapshot + 1)\n      return undefined;\n    if (row == snapshot + 2)\n      return totalHeaderRow[column];\n    \n    if (row == snapshot + 3)\n      return this.totalRow(snapshot, column);\n\n    const dateTime = this.dateTime(row);\n    switch (column) { \n      case 0: return dateTime;\n      case 1: return dateTime;\n      case 2: return \"Nails\";\n      case 3: return 0.01;\n      case 4: return 80;\n      case 5: return 0.80;\n      case 6: return 0.15;\n      case 7: return 0.12;\n      case 8: return 0.92;\n      case 9: return 0.08;\n      case 10: return 1.00;\n      case 11: return row;\n    }\n  }\n  getCellFormat(snapshot: number, row: number, column: number) { \n    if (row == snapshot + 3 && column == 1)\n      return \"yyyy-mm-dd\";\n\n    switch (column) {\n      case 0:\n        return \"yyyy-mm-dd\";\n      case 1:\n        return \"hh:mm\";\n      case 6:\n        return \"0%\";\n      case 3:\n      case 5:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n        return \"$0.00\";\n      default:\n        return undefined; \n    }\n  }\n\n  count: number;\n  base: number;\n}","import { VirtualSpreadsheet, VirtualSpreadsheetDefaultTheme as theme } from '@candidstartup/react-spreadsheet';\nimport '@candidstartup/react-spreadsheet/VirtualSpreadsheet.css';\nimport './App.css';\nimport { BoringData } from './BoringData';\n\nconst data = new BoringData;\n\nexport function App() {\n  return (\n    <VirtualSpreadsheet\n    data={data}\n    theme={theme}\n    height={300}\n    width={600}>\n  </VirtualSpreadsheet>\n  )\n}\n","import React from 'react'\nimport { createRoot } from 'react-dom/client';\nimport { App } from './App'\n\ncreateRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)\n"],"names":["defaultContainerRender","rest","ref","jsx","VirtualContainer","React","render","AutoSizer","props","children","className","style","width","setWidth","height","setHeight","resizeCallback","entries","entry","newWidth","newHeight","div","resizeObserver","renderChildren","MAX_SUPPORTED_CSS_SIZE","MIN_NUMBER_PAGES","useVirtualScroll","totalSize","maxCssSize","minNumberPages","useTotalOffset","renderSize","pageSize","numPages","pageToRenderOffset","page","initValue","totalOffset","setTotalOffset","useState","scrollState","useRef","onScroll","clientExtent","scrollExtent","scrollOffset","currState","newOffset","newScrollDirection","newPage","newRenderOffset","retScrollOffset","scaleFactor","newScrollState","doScrollTo","offset","safeOffset","scrollDirection","renderOffset","getCurrentOffset","isListener","element","useEventListener","eventName","handler","options","savedHandler","capture","passive","once","useEffect","el","eventListener","event","_a","opts","it","expect","createRef","useAnimationTimeout","callback","delay","key","requestRef","savedCallback","start","tick","DEBOUNCE_INTERVAL","FALLBACK_INTERVAL","useIsScrolling","scrollCount","setScrollCount","supportsScrollEnd","c","getOffsetToScrollRange","size","option","endOffset","endViewport","VirtualScroll","scrollWidth","scrollHeight","innerClassName","onScrollCallback","useOffsets","innerRender","outerRender","outerRef","currentVerticalOffset","renderRowSize","onScrollRow","doScrollToRow","getVerticalOffset","currentHorizontalOffset","renderColumnSize","onScrollColumn","doScrollToColumn","getHorizontalOffset","isActuallyScrolling","useIsScrollingHook","rowOffset","columnOffset","outer","verticalOffset","verticalSize","horizontalOffset","horizontalSize","colOffset","clientWidth","clientHeight","scrollLeft","scrollTop","newScrollTop","newRowScrollState","newScrollLeft","newColumnScrollState","isScrolling","jsxs","getRangeToRender","itemCount","itemOffsetMapping","baseIndex","startOffset","itemIndex","startIndex","sizes","formatRepeat","repeat","join","a","s","getGridTemplate","count","ret","lastSize","i","defaultItemKey","index","_data","boxStyle","DisplayList","itemData","itemKey","layout","isVertical","template","ChildVar","_size","arrayIndex","rowIndex","columnIndex","DisplayGrid","rowCount","rowOffsetMapping","columnCount","columnOffsetMapping","rowRenderOffset","colRenderOffset","rowStartIndex","rowStartOffset","rowRenderSize","rowSizes","rowTemplate","colStartIndex","colStartOffset","colRenderSize","colSizes","colTemplate","_rowSize","Fragment","colIndex","getRangeToScroll","mapping","virtualGridScrollToItem","scrollRef","scroll","rowSize","colSize","scrollProps","totalRowSize","totalColumnSize","verticalScrollState","horizontalScrollState","virtualListScrollToItem","itemOffset","itemSize","FixedSizeItemOffsetMapping","__publicField","_itemIndex","useFixedSizeItemOffsetMapping","VariableSizeItemOffsetMapping","defaultItemSize","length","useVariableSizeItemOffsetMapping","rowItemOffsetMapping","columnItemOffsetMapping","EmptySpreadsheetData","_onDataChange","_snapshot","_row","_column","_value","_format","colRefToIndex","col","n","indexToColRef","remainder","splitRowColRef","re","found","row","rowColRefToCoords","rowColCoordsToRef","VirtualSpreadsheetDefaultTheme","v","ifdef","b","numfmtOptions","formatContent","value","format","numfmt.format","classForType","type","HeaderItem","data","Cell","VirtualSpreadsheet","theme","minRowCount","minColumnCount","maxRowCount","maxColumnCount","focusSinkRef","subscribeFn","cb","snapshot","name","setName","formula","setFormula","cellValue","setCellValue","editMode","setEditMode","hwmRowIndex","setHwmRowIndex","hwmColumnIndex","setHwmColumnIndex","selection","setSelection","focusCell","setFocusCell","gridRowOffset","gridColumnOffset","setGridScrollState","dataRowCount","rowMapping","dataColumnCount","columnMapping","rowOffsetValue","columnOffsetValue","updateFormula","dataValue","updateFocus","updateSelection","ensureVisible","rowRange","colRange","newRowOffset","newColOffset","isInSelection","selectItem","keepSelection","nextCell","isBackwards","onNameKeyUp","CommitFormulaChange","parseData","numfmt.parseValue","onEditValueKeyDown","colSelected","colCellSelected","rowSelected","rowCellSelected","colHeaderRender","headerRect","rowHeaderRender","colRender","rowRender","outerGridRender","focusSink","focusHeight","focusTop","focusWidth","focusLeft","_b","gridRect","_event","cellRender","focused","classNames","_","headerRow","totalHeaderRow","BoringData","serialNow","dateToSerial","onDataChange","intervalId","num","column","dateTime","App","createRoot"],"mappings":"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"}