{"version":3,"file":"useFixedSizeItemOffsetMapping-DIBrUQ8f.js","sources":["../../../../packages/react-virtual-scroll/src/VirtualBase.ts","../../../../packages/react-virtual-scroll/src/useVirtualScroll.ts","../../../../packages/react-virtual-scroll/src/useEventListener.ts","../../../../packages/react-virtual-scroll/src/useAnimationTimeout.ts","../../../../packages/react-virtual-scroll/src/useIsScrolling.ts","../../../../packages/react-virtual-scroll/src/VirtualGrid.tsx","../../../../packages/react-virtual-scroll/src/VirtualList.tsx","../../../../packages/react-virtual-scroll/src/useFixedSizeItemOffsetMapping.ts"],"sourcesContent":["\nexport interface VirtualBaseItemProps {\n  data: any,\n  isScrolling?: boolean,\n  style: Object,\n};\n\nexport interface VirtualBaseProps {\n  height: number,\n  width: number,\n  itemData?: any,\n  useIsScrolling?: boolean,\n  maxCssSize?: number,\n  minNumPages?: number\n};\n\nexport interface ItemOffsetMapping {\n  itemSize(itemIndex: number): number;\n  itemOffset(itemIndex: number): number;\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number];\n};\n\nexport type ScrollEvent = React.SyntheticEvent<HTMLDivElement>;\n\ntype RangeToRender = [\n  startIndex: number,\n  startOffset: number,\n  sizes: number[]\n];\n\nexport function getRangeToRender(itemCount: number, itemOffsetMapping: ItemOffsetMapping, clientExtent: number, scrollOffset: number): RangeToRender {\n  if (itemCount == 0) {\n    return [0, 0, []];\n  }\n\n  var [itemIndex, startOffset] = itemOffsetMapping.offsetToItem(scrollOffset);\n  itemIndex = Math.max(0, Math.min(itemCount - 1, itemIndex));\n  var endOffset = scrollOffset + clientExtent;\n\n  const overscanBackward = 1;\n  const overscanForward = 1;\n\n  for (let step = 0; step < overscanBackward && itemIndex > 0; step ++) {\n    itemIndex --;\n    startOffset -= itemOffsetMapping.itemSize(itemIndex);\n  }\n\n  const startIndex = itemIndex;\n  var offset = startOffset;\n  const sizes: number[] = [];\n\n  while (offset < endOffset && itemIndex < itemCount) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    offset += size;\n    itemIndex ++;\n  }\n\n  for (let step = 0; step < overscanForward && itemIndex < itemCount; step ++) {\n    const size = itemOffsetMapping.itemSize(itemIndex);\n    sizes.push(size);\n    itemIndex ++;\n  }\n\n  return [startIndex, startOffset, sizes];\n}\n","import { useState } from \"react\";\n\nexport type ScrollDirection = \"forward\" | \"backward\";\nexport interface ScrollState { \n  scrollOffset: number, \n  renderOffset: number,\n  page: number, \n  scrollDirection: ScrollDirection, \n};\n\nexport interface VirtualScroll extends ScrollState {\n  renderSize: number;\n\n  // Returns updated scrollOffset. Caller should update scroll bar position if different from value passed in. \n  onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState];\n\n  // Scroll to offset in logical space returning offset to update scroll bar position to\n  doScrollTo(offset: number, clientExtent: number): number;\n};\n\n// Max size that is safe across all browsers (Firefox is the limiting factor)\n// SlickGrid tries to dynamically determine limit on other browsers (Chrome will do 30M) but\n// I prefer simplicity of same behavior across all browsers.\nconst MAX_SUPPORTED_CSS_SIZE = 6000000;\nconst MIN_NUMBER_PAGES = 100;\n\nexport function useVirtualScroll(totalSize: number, maxCssSize = MAX_SUPPORTED_CSS_SIZE, minNumberPages = MIN_NUMBER_PAGES): VirtualScroll {\n  let renderSize=0, pageSize=0, numPages=0;\n  if (totalSize < maxCssSize) {\n    // No paging needed\n    renderSize = pageSize = totalSize;\n    numPages = 1;\n  } else {\n    // Break into pages\n    renderSize = maxCssSize;\n    pageSize = renderSize / minNumberPages;\n    numPages = Math.floor(totalSize / pageSize);\n  }\n\n  function pageToRenderOffset(page: number): number {\n    if (page <= 0)\n      return 0;\n\n    if (page >= numPages-1)\n      return totalSize - renderSize;\n\n    return Math.round((page-1) * (totalSize - renderSize) / (numPages - 3));\n  }\n\n  const initValue: ScrollState = { \n    scrollOffset: 0, \n    renderOffset: 0,\n    page: 0,\n    scrollDirection: \"forward\",\n  };\n  const [scrollState, setScrollState] = useState(initValue);\n\n  function onScroll(clientExtent: number, scrollExtent: number, scrollOffset: number): [number, ScrollState] {\n    if (scrollState.scrollOffset == scrollOffset) {\n      // No need to change state if scroll position unchanged\n      return [scrollOffset, scrollState];\n    }\n\n    // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n    let newOffset = Math.max(0, Math.min(scrollOffset, scrollExtent - clientExtent));\n    const newScrollDirection = scrollState.scrollOffset <= newOffset ? 'forward' : 'backward';\n\n    // Switch pages if needed\n    let newPage, newRenderOffset;\n    let retScrollOffset = scrollOffset;\n    const scrollDist = Math.abs(newOffset - scrollState.scrollOffset);\n    if (scrollDist < clientExtent) {\n      // Scrolling part of visible window, don't want to skip items, so can't scale up movement\n      // If we cross page boundary we need to reset scroll bar position back to where it should be at start of page\n      newPage = Math.min(numPages - 1, Math.floor((scrollOffset + scrollState.renderOffset) / pageSize));\n      newRenderOffset = pageToRenderOffset(newPage);\n      if (newPage != scrollState.page) {\n        // Be very intentional about when we ask caller to reset scroll bar\n        // Don't want to trigger event loops\n        newOffset = scrollOffset + scrollState.renderOffset - newRenderOffset;\n        retScrollOffset = newOffset;\n      }\n    } else {\n      // Large scale scrolling, choosing page from a rolodex\n      // First and last page are mapped 1:1 between grid and container\n      if (newOffset < pageSize) {\n        newPage = 0;\n      } else if (newOffset >= renderSize - pageSize) {\n        newPage = numPages - 1;\n      } else {\n        const scaleFactor = (totalSize - pageSize*2) / (renderSize - pageSize*2);\n        newPage = Math.min(numPages - 3, Math.floor((newOffset - pageSize) * scaleFactor / pageSize)) + 1;\n      }\n      newRenderOffset = pageToRenderOffset(newPage);\n    }\n\n    const newScrollState: ScrollState = \n      { scrollOffset: newOffset, renderOffset: newRenderOffset, page: newPage, scrollDirection: newScrollDirection };\n    setScrollState(newScrollState);\n    return [retScrollOffset, newScrollState];\n  }\n\n  function doScrollTo(offset: number, clientExtent: number) {\n    const safeOffset = Math.min(totalSize - clientExtent, Math.max(offset, 0));\n    const scrollDirection = (scrollState.scrollOffset + scrollState.renderOffset) <= safeOffset ? 'forward' : 'backward';\n    const page = Math.min(numPages - 1, Math.floor(safeOffset / pageSize));\n    const renderOffset = pageToRenderOffset(page);\n    const scrollOffset = safeOffset - renderOffset;\n\n    setScrollState({ scrollOffset, renderOffset, page, scrollDirection });\n    return scrollOffset;\n  }\n\n  return {...scrollState, renderSize, onScroll, doScrollTo} as const;\n}\n\nexport default useVirtualScroll;\n","// Based on https://github.com/realwugang/use-event-listener\n// and https://github.com/donavon/use-event-listener/blob/develop/src/index.js\n\nimport { useRef, useEffect, RefObject, createRef } from 'react';\n\ninterface Options {\n  capture?: boolean\n  once?: boolean\n  passive?: boolean\n};\n\ntype Listener = Window | Document | HTMLElement;\n\nfunction isListener(element: Listener | RefObject<HTMLElement>): element is Listener {\n  return (element as Listener).addEventListener !== undefined;\n}\n\nexport function useEventListener (eventName: string, \n                                  handler: (event: Event) => void, \n                                  element: Listener | RefObject<HTMLElement> | null = window, \n                                  options: Options = {}) {\n  const savedHandler = useRef<any>();\n  const { capture, passive, once } = options;\n\n  useEffect(() => {\n    savedHandler.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    if (!element)\n      return;\n\n    const el =  isListener(element) ? element : element.current;\n    if (!el)\n      return;\n\n    const eventListener = (event: Event) => savedHandler.current(event);\n    const opts = { capture, passive, once };\n    el.addEventListener(eventName, eventListener, opts);\n    return () => {\n      el.removeEventListener(eventName, eventListener, opts);\n    };\n  }, [eventName, element, capture, passive, once]);\n}\n\nexport default useEventListener;\n\n// In-source testing for private helper functions\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('isListener', () => {\n    expect(isListener(window)).toBe(true)\n    expect(isListener(document)).toBe(true)\n    expect(isListener(document.createElement(\"div\"))).toBe(true)\n    expect(isListener(createRef())).toBe(false)\n  })\n}","// Based on https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n// and https://www.joshwcomeau.com/snippets/react-hooks/use-timeout/\n// and https://github.com/bvaughn/react-window/blob/master/src/timer.js\n//\n// Equivalent functionality to a useTimeout hook but based on requestAnimationFrame instead of setTimeout. Use\n// when making frequent requests for short duration timeouts where browser may throttle setTimeout.\nimport { useEffect, useRef } from 'react';\n\ntype Callback = () => void;\n\nexport function useAnimationTimeout(callback: Callback, delay: number | null, key?: unknown) {\n  const requestRef = useRef<number>();\n  const savedCallback = useRef<Callback>(callback);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n \n  const start = performance.now();\n  \n  useEffect(() => {\n    function tick() {\n      requestRef.current = undefined;\n      if (delay === null)\n        return;\n\n      if (performance.now() - start >= delay) {\n        savedCallback.current();\n      } else {\n        requestRef.current = requestAnimationFrame(tick);\n      }\n    }\n\n    tick();\n\n    return () => {\n      if (typeof requestRef.current === 'number') {\n        cancelAnimationFrame(requestRef.current);\n        requestRef.current = undefined;\n      }\n    }\n  }, [delay, key]);\n}\n\nexport default useAnimationTimeout;","import { useState, RefObject } from \"react\";\nimport { useEventListener } from './useEventListener';\nimport { useAnimationTimeout } from './useAnimationTimeout';\n\nconst DEBOUNCE_INTERVAL = 150;\nconst FALLBACK_INTERVAL = 500;\n\nexport function useIsScrolling(element: Window | HTMLElement | RefObject<HTMLElement> | null = window): boolean {\n  const [scrollCount, setScrollCount] = useState(0);\n\n  // scrollend implementations in both Chrome and Firefox are buggy with missing scrollend events\n  // in some circumstances (using keyboard to scroll past end in Chrome, intermittently when using mouse wheel in Firefox)\n  // Use a timeout even when scrollend is supported to handle missing events. In this case we use a longer interval as\n  // don't want it to be over sensitive. \n  const supportsScrollEnd = ('onscrollend' in window);\n  const delay = supportsScrollEnd ? FALLBACK_INTERVAL : DEBOUNCE_INTERVAL;\n\n  useEventListener(\"scroll\", () => setScrollCount(c => c + 1), element);\n  useEventListener(\"scrollend\", () => setScrollCount(0), supportsScrollEnd ? element : null);\n  useAnimationTimeout(() => setScrollCount(0), (scrollCount == 0) ? null : delay, scrollCount);\n\n  return scrollCount > 0;\n}\n\nexport default useIsScrolling;","import React from \"react\";\nimport { Fragment } from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, VirtualBaseProps, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll, ScrollState } from './useVirtualScroll';\nexport type { ScrollState } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport interface VirtualGridItemProps extends VirtualBaseItemProps {\n  rowIndex: number,\n  columnIndex: number,\n};\n\ntype VirtualGridItem = React.ComponentType<VirtualGridItemProps>;\n\nexport interface VirtualGridProps extends VirtualBaseProps {\n  children: VirtualGridItem,\n  rowCount: number,\n  rowOffsetMapping: ItemOffsetMapping,\n  columnCount: number,\n  columnOffsetMapping: ItemOffsetMapping,\n  itemKey?: (rowIndex: number, columnIndex: number, data: any) => any,\n  onScroll?: (rowOffset: number, columnOffset: number, newRowScrollState: ScrollState, newColumnScrollState: ScrollState) => void;\n};\n\nexport interface VirtualGridProxy {\n  scrollTo(rowOffset: number, columnOffset: number): void;\n  scrollToItem(rowIndex: number, columnIndex: number): void;\n};\n\nconst defaultItemKey = (rowIndex: number, columnIndex: number, _data: any) => `${rowIndex}:${columnIndex}`;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualGrid = React.forwardRef<VirtualGridProxy, VirtualGridProps>(function VirtualGrid(props, ref) {\n  const { width, height, rowCount, rowOffsetMapping, columnCount, columnOffsetMapping, children, \n    itemData = undefined, itemKey = defaultItemKey, onScroll: onScrollCallback, useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalRowSize = rowOffsetMapping.itemOffset(rowCount);\n  const totalColumnSize = columnOffsetMapping.itemOffset(columnCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset: scrollRowOffset, renderOffset: renderRowOffset, renderSize: renderRowSize,\n    onScroll: onScrollRow, doScrollTo: doScrollToRow } = useVirtualScroll(totalRowSize, props.maxCssSize, props.minNumPages);\n  const { scrollOffset: scrollColumnOffset, renderOffset: renderColumnOffset, renderSize: renderColumnSize,\n    onScroll: onScrollColumn, doScrollTo: doScrollToColumn} = useVirtualScroll(totalColumnSize, props.maxCssSize, props.minNumPages);\n  const isScrolling = useIsScrollingHook(outerRef); \n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(rowOffset: number, columnOffset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer)\n          outer.scrollTo(doScrollToColumn(columnOffset, outer.clientWidth), doScrollToRow(rowOffset, outer.clientHeight));\n      },\n\n      scrollToItem(rowIndex: number, columnIndex: number): void {\n        this.scrollTo(rowOffsetMapping.itemOffset(rowIndex), columnOffsetMapping.itemOffset(columnIndex));\n      }\n    }\n  }, [ rowOffsetMapping, columnOffsetMapping, doScrollToRow, doScrollToColumn ]);\n\n\n  function onScroll(event: ScrollEvent) {\n    const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollLeft, scrollTop } = event.currentTarget;\n    const [newScrollTop, newRowScrollState] = onScrollRow(clientHeight, scrollHeight, scrollTop);\n    const [newScrollLeft, newColumnScrollState] = onScrollColumn(clientWidth, scrollWidth, scrollLeft);\n    if (outerRef.current && (newScrollTop != scrollTop || newScrollLeft != scrollLeft ))\n      outerRef.current.scrollTo(newScrollLeft, newScrollTop);\n    onScrollCallback?.(newRowScrollState.scrollOffset+newRowScrollState.renderOffset, \n      newColumnScrollState.scrollOffset+newColumnScrollState.renderOffset, newRowScrollState, newColumnScrollState);\n  }\n\n  const [startRowIndex, startRowOffset, rowSizes] = \n    getRangeToRender(rowCount, rowOffsetMapping, height, scrollRowOffset + renderRowOffset);\n  const [startColumnIndex, startColumnOffset, columnSizes] = \n    getRangeToRender(columnCount, columnOffsetMapping, width, scrollColumnOffset + renderColumnOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextRowOffset = startRowOffset - renderRowOffset;\n  let rowIndex=0, rowOffset=0;\n  let nextColumnOffset=0, columnIndex=0, columnOffset=0;\n\n  return (\n    <div onScroll={onScroll} ref={outerRef} style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <div style={{ height: renderRowSize, width: renderColumnSize }}>\n        {rowSizes.map((rowSize, rowArrayIndex) => (\n          rowOffset = nextRowOffset,\n          nextRowOffset += rowSize,\n          rowIndex = startRowIndex + rowArrayIndex,\n          nextColumnOffset = startColumnOffset - renderColumnOffset,\n          <Fragment key={itemKey(rowIndex, 0, itemData)}>\n          {columnSizes.map((columnSize, columnArrayIndex) => (\n            columnOffset = nextColumnOffset,\n            nextColumnOffset += columnSize,\n            columnIndex = startColumnIndex + columnArrayIndex,\n            <ChildVar data={itemData} key={itemKey(rowIndex, columnIndex, itemData)}\n                      rowIndex={rowIndex} columnIndex={columnIndex}\n                      isScrolling={useIsScrolling ? isScrolling : undefined}\n                      style={{ position: \"absolute\", top: rowOffset, height: rowSize, left: columnOffset, width: columnSize }}/>\n          ))}\n          </Fragment>\n        ))}\n      </div>\n    </div>\n  );\n});\n\nexport default VirtualGrid;\n","import React from \"react\";\nimport { ItemOffsetMapping, getRangeToRender, VirtualBaseItemProps, VirtualBaseProps, ScrollEvent } from './VirtualBase';\nimport { useVirtualScroll, ScrollState } from './useVirtualScroll';\nexport type { ScrollState } from './useVirtualScroll';\nimport { useIsScrolling as useIsScrollingHook} from './useIsScrolling';\n\nexport type ScrollLayout = \"horizontal\" | \"vertical\";\n\nexport interface VirtualListItemProps extends VirtualBaseItemProps {\n  index: number,\n};\n\ntype VirtualListItem = React.ComponentType<VirtualListItemProps>;\n\nexport interface VirtualListProps extends VirtualBaseProps {\n  children: VirtualListItem,\n  itemCount: number,\n  itemOffsetMapping: ItemOffsetMapping,\n  itemKey?: (index: number, data: any) => any,\n  layout?: ScrollLayout,\n  onScroll?: (offset: number, newScrollState: ScrollState) => void;\n};\n\nexport interface VirtualListProxy {\n  scrollTo(offset: number): void;\n  scrollToItem(index: number): void;\n};\n\nconst defaultItemKey = (index: number, _data: any) => index;\n\n// Using a named function rather than => so that the name shows up in React Developer Tools\nexport const VirtualList = React.forwardRef<VirtualListProxy, VirtualListProps>(function VirtualList(props, ref) {\n  const { width, height, itemCount, itemOffsetMapping, children, \n    itemData = undefined, itemKey = defaultItemKey, layout = 'vertical', onScroll: onScrollCallback, useIsScrolling = false } = props;\n\n  // Total size is same as offset to item one off the end\n  const totalSize = itemOffsetMapping.itemOffset(itemCount);\n\n  const outerRef = React.useRef<HTMLDivElement>(null);\n  const { scrollOffset, renderOffset, renderSize, onScroll: onScrollExtent, doScrollTo } = \n    useVirtualScroll(totalSize, props.maxCssSize, props.minNumPages);\n  const isScrolling = useIsScrollingHook(outerRef); \n  const isVertical = layout === 'vertical';\n\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollTo(offset: number): void {\n        const outer = outerRef.current;\n        /* istanbul ignore else */\n        if (outer) {\n          if (isVertical)\n            outer.scrollTo(0, doScrollTo(offset, outer.clientHeight));\n          else\n            outer.scrollTo(doScrollTo(offset, outer.clientWidth), 0);\n        }\n      },\n\n      scrollToItem(index: number): void {\n        this.scrollTo(itemOffsetMapping.itemOffset(index));\n      }\n    }\n  }, [ itemOffsetMapping, isVertical, doScrollTo ]);\n\n  function onScroll(event: ScrollEvent) {\n    if (isVertical) {\n      const { clientHeight, scrollHeight, scrollTop, scrollLeft } = event.currentTarget;\n      const [newScrollTop, newScrollState] = onScrollExtent(clientHeight, scrollHeight, scrollTop);\n      if (newScrollTop != scrollTop && outerRef.current)\n        outerRef.current.scrollTo(scrollLeft, newScrollTop);\n      onScrollCallback?.(newScrollState.scrollOffset+newScrollState.renderOffset, newScrollState);\n    } else {\n      const { clientWidth, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n      const [newScrollLeft, newScrollState] = onScrollExtent(clientWidth, scrollWidth, scrollLeft);\n      if (newScrollLeft != scrollLeft && outerRef.current)\n        outerRef.current.scrollTo(newScrollLeft, scrollTop);\n      onScrollCallback?.(newScrollState.scrollOffset+newScrollState.renderOffset, newScrollState);\n    }\n  }\n\n  const [startIndex, startOffset, sizes] = getRangeToRender(itemCount, itemOffsetMapping, \n    isVertical ? height : width, scrollOffset+renderOffset);\n\n  // We can decide the JSX child type at runtime as long as we use a variable that uses the same capitalized\n  // naming convention as components do. \n  const ChildVar = children;\n\n  // Being far too clever. Implementing a complex iteration in JSX in a map expression by abusing the comma operator. \n  // You can't declare local variables in an expression so they need to be hoisted out of the JSX. The comma operator\n  // returns the result of the final statement which makes the iteration a little clumsier.\n  let nextOffset = startOffset - renderOffset;\n  let index, offset;\n\n  return (\n    <div onScroll={onScroll} ref={outerRef} style={{ position: \"relative\", height, width, overflow: \"auto\", willChange: \"transform\" }}>\n      <div style={{ height: isVertical ? renderSize : \"100%\", width: isVertical ? \"100%\" : renderSize }}>\n        {sizes.map((size, arrayIndex) => (\n          offset = nextOffset,\n          nextOffset += size,\n          index = startIndex + arrayIndex,\n          <ChildVar data={itemData} key={itemKey(index, itemData)} index={index}\n            isScrolling={useIsScrolling ? isScrolling : undefined}\n            style={{ \n              position: \"absolute\", \n              top: isVertical ? offset : undefined, \n              left: isVertical ? undefined : offset,\n              height: isVertical ? size : \"100%\", \n              width: isVertical ? \"100%\" : size, \n            }}/>\n        ))}\n      </div>\n    </div>\n  );\n});\n\nexport default VirtualList;\n","import { ItemOffsetMapping } from './VirtualBase';\n\nclass FixedSizeItemOffsetMapping implements ItemOffsetMapping {\n  constructor (itemSize: number) {\n    this.fixedItemSize = itemSize;\n  }\n\n  itemSize(_itemIndex: number): number {\n    return this.fixedItemSize;\n  }\n\n  itemOffset(itemIndex: number): number {\n    return itemIndex * this.fixedItemSize;\n  }\n\n  offsetToItem(offset: number): [itemIndex: number, startOffset: number] {\n    const itemIndex = Math.floor(offset / this.fixedItemSize);\n    const startOffset = itemIndex * this.fixedItemSize;\n\n    return [itemIndex, startOffset];\n  }\n\n  fixedItemSize: number;\n};\n\nexport function useFixedSizeItemOffsetMapping(itemSize: number) {\n  return new FixedSizeItemOffsetMapping(itemSize);\n};\n\nexport default useFixedSizeItemOffsetMapping;\n"],"names":["getRangeToRender","itemCount","itemOffsetMapping","clientExtent","scrollOffset","itemIndex","startOffset","endOffset","overscanBackward","overscanForward","step","startIndex","offset","sizes","size","MAX_SUPPORTED_CSS_SIZE","MIN_NUMBER_PAGES","useVirtualScroll","totalSize","maxCssSize","minNumberPages","renderSize","pageSize","numPages","pageToRenderOffset","page","initValue","scrollState","setScrollState","useState","onScroll","scrollExtent","newOffset","newScrollDirection","newPage","newRenderOffset","retScrollOffset","scaleFactor","newScrollState","doScrollTo","safeOffset","scrollDirection","renderOffset","isListener","element","useEventListener","eventName","handler","options","savedHandler","useRef","capture","passive","once","useEffect","el","eventListener","event","opts","it","expect","createRef","useAnimationTimeout","callback","delay","key","requestRef","savedCallback","start","tick","DEBOUNCE_INTERVAL","FALLBACK_INTERVAL","useIsScrolling","scrollCount","setScrollCount","supportsScrollEnd","c","defaultItemKey","rowIndex","columnIndex","_data","VirtualGrid","React","props","ref","width","height","rowCount","rowOffsetMapping","columnCount","columnOffsetMapping","children","itemData","itemKey","onScrollCallback","totalRowSize","totalColumnSize","outerRef","scrollRowOffset","renderRowOffset","renderRowSize","onScrollRow","doScrollToRow","scrollColumnOffset","renderColumnOffset","renderColumnSize","onScrollColumn","doScrollToColumn","isScrolling","useIsScrollingHook","rowOffset","columnOffset","outer","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollLeft","scrollTop","newScrollTop","newRowScrollState","newScrollLeft","newColumnScrollState","startRowIndex","startRowOffset","rowSizes","startColumnIndex","startColumnOffset","columnSizes","ChildVar","nextRowOffset","nextColumnOffset","jsx","rowSize","rowArrayIndex","Fragment","columnSize","columnArrayIndex","index","VirtualList","layout","onScrollExtent","isVertical","nextOffset","arrayIndex","FixedSizeItemOffsetMapping","itemSize","__publicField","_itemIndex","useFixedSizeItemOffsetMapping"],"mappings":"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"}